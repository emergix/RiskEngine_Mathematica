(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Off[X::"shdw"]


(* ::Input::Initialization:: *)
<<Optimization`UnconstrainedProblems`


(* ::Input::Initialization:: *)
Off[NIntegrate::"slwcon",N::"meprec",FindMinimum::"eit",NIntegrate::"eincr",FindMinimum::"cvmit"]


(* ::Input::Initialization:: *)
NormalCallPayOff[S0_,k_,\[Lambda]_]:=E^(-\[Lambda] S0) (S0-k) UnitStep[S0-k]


(* ::Input::Initialization:: *)
NormalCallPayOff[S0_,k_,\[Alpha]_,a_,\[Lambda]_]:=E^(-\[Lambda] S0) (\[Alpha] S0^a-k) UnitStep[\[Alpha] S0^a-k]


(* ::Input::Initialization:: *)
NormalPutPayOff[S0_,k_,\[Lambda]_]:=NormalCallPayOff[-S0,-k,\[Lambda]]


(* ::Input::Initialization:: *)
NormalCallPayOffFourierTransform[k_,\[Omega]_]:=-((E^ (I k \[Omega]))/  (\[Omega]^2))


(* ::Input::Initialization:: *)
NormalCallPayOffFourierTransform[k_,\[Alpha]_,a_,\[Omega]_]:=-((I (E^(I (k/\[Alpha])^(1/a) \[Omega]) k-\[Alpha] (-I \[Omega])^-a Gamma[1+a,-I (k/\[Alpha])^(1/a) \[Omega]]))/\[Omega])


(* ::Input::Initialization:: *)
LogNormalCallPayOff[S0_,k_]:= (E^S0-k)UnitStep[E^S0-k]


(* ::Input::Initialization:: *)
LogNormalCallPayOff[S0_,k_,\[Alpha]_,a_]:= (\[Alpha] E^(a S0)-k)UnitStep[\[Alpha] E^(a S0)-k]


(* ::Input::Initialization:: *)
LogNormalCallPayOffFourierTransform[k_,\[Omega]_]:=k^(1+I \[Omega])/(  (\[Omega]-I)\[Omega])


(* ::Input::Initialization:: *)
LogNormalCallPayOffFourierTransform[k_,n_,\[Omega]_]:=(k^(1+(I \[Omega])/n) n)/(\[Omega]^2-I \[Omega] n)


(* ::Input::Initialization:: *)
LogNormalCallPayOffFourierTransform[K_,\[Alpha]_,a_,\[Omega]_]:=(a K (K/\[Alpha])^((I \[Omega])/a))/(\[Omega]^2-I a \[Omega])


(* ::Input::Initialization:: *)
NormalHestonFondamentalTransform[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,\[Omega]_,\[Tau]_]:=Module[{\[Zeta],\[Psi]p ,\[Psi]m,A,B,arg\[Zeta],\[Eta]},
\[Eta]=\[Lambda]v+\[Rho] \[Kappa] I \[Omega];
arg\[Zeta]=\[Eta]^2+\[Kappa]^2 \[Omega]^2;
\[Zeta]=Sqrt[arg\[Zeta]];
\[Psi]p =-\[Eta]+\[Zeta];
\[Psi]m =\[Eta]+\[Zeta];
A=-(( \[Theta]v \[Lambda]v (\[Tau] \[Psi]p+2 Log[(\[Psi]m+E^(-\[Zeta] \[Tau]) \[Psi]p)/(2\[Zeta])]))/ (\[Kappa]^2)   );
B=( -\[Omega]^2(1-E^(-\[Zeta]  \[Tau])))/(\[Psi]m+\[Psi]p E^(-\[Zeta]  \[Tau]));
If[Re[A+B V]<-100,0,
E^(A+B V)]]


(* ::Input::Initialization:: *)
NormalHestonFondamentalTransform[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Omega]_,\[Tau]_]:=
Module[{\[Zeta]1,\[Psi]p1 ,\[Psi]m1,B1,arg\[Zeta]1,\[Eta]1,\[Zeta]2,\[Psi]p2 ,\[Psi]m2,A2,B2,arg\[Zeta]2,\[Eta]2,A},
\[Eta]1=\[Lambda]v1+\[Rho]1 \[Kappa]1 I \[Omega];
arg\[Zeta]1=\[Eta]1^2+\[Kappa]1^2 \[Omega]^2;
\[Zeta]1=Sqrt[arg\[Zeta]1];
\[Psi]p1 =-\[Eta]1+\[Zeta]1;
\[Psi]m1 =\[Eta]1+\[Zeta]1;
B1=( -\[Omega]^2(1-E^(-\[Zeta]1  \[Tau])))/(\[Psi]m1+\[Psi]p1 E^(-\[Zeta]1  \[Tau]));
\[Eta]2=\[Lambda]v2+\[Rho]2 \[Kappa]2 I \[Omega];
arg\[Zeta]2=\[Eta]2^2+\[Kappa]2^2 \[Omega]^2;
\[Zeta]2=Sqrt[arg\[Zeta]2];
\[Psi]p2 =-\[Eta]2+\[Zeta]2;
\[Psi]m2 =\[Eta]2+\[Zeta]2;
B2=( -\[Omega]^2(1-E^(-\[Zeta]2  \[Tau])))/(\[Psi]m2+\[Psi]p2 E^(-\[Zeta]2  \[Tau]));
A=-(( \[Theta]v1 \[Lambda]v1 (\[Tau] \[Psi]p1+2 Log[(\[Psi]m1+E^(-\[Zeta]1 \[Tau]) \[Psi]p1)/(2\[Zeta]1)]))/ (\[Kappa]1^2)   )-( \[Theta]v2 \[Lambda]v2 (\[Tau] \[Psi]p2+2 Log[(\[Psi]m2+E^(-\[Zeta]2 \[Tau]) \[Psi]p2)/(2\[Zeta]2)]))/ (\[Kappa]2^2)   ;
If[Re[A+B1 V1+B2 V2]<-100,0,
E^(A+B1 V1+B2 V2)]
]


(* ::Input::Initialization:: *)
NormalHestonFondamentalTransform[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Omega]_,\[Tau]_]:=
Module[{\[Zeta]1,\[Psi]p1 ,\[Psi]m1,arg\[Zeta]1,\[Eta]1,\[Zeta]2,\[Psi]p2 ,\[Psi]m2,arg\[Zeta]2,\[Eta]2,\[Zeta]3,\[Psi]p3 ,\[Psi]m3,A3,arg\[Zeta]3,\[Eta]3,B1,B2,B3,A},
\[Eta]1=\[Lambda]v1+\[Rho]1 \[Kappa]1 I \[Omega];
arg\[Zeta]1=(\[Lambda]v1+\[Rho]1 \[Kappa]1 I \[Omega])^2+\[Kappa]1^2 \[Omega]^2;
\[Zeta]1=Sqrt[arg\[Zeta]1];
\[Psi]p1 =-\[Eta]1+\[Zeta]1;
\[Psi]m1 =\[Eta]1+\[Zeta]1;
B1=( -\[Omega]^2(1-E^(-\[Zeta]1  \[Tau])))/(\[Psi]m1+\[Psi]p1 E^(-\[Zeta]1  \[Tau]));
\[Eta]2=\[Lambda]v2+\[Rho]2 \[Kappa]2 I \[Omega];
arg\[Zeta]2=\[Eta]2^2+\[Kappa]2^2 \[Omega]^2;
\[Zeta]2=Sqrt[arg\[Zeta]2];
\[Psi]p2 =-\[Eta]2+\[Zeta]2;
\[Psi]m2 =\[Eta]2+\[Zeta]2;
B2=( -\[Omega]^2(1-E^(-\[Zeta]2  \[Tau])))/(\[Psi]m2+\[Psi]p2 E^(-\[Zeta]2  \[Tau]));
\[Eta]3=\[Lambda]v3+\[Rho]3 \[Kappa]3 I \[Omega];
arg\[Zeta]3=\[Eta]3^2+\[Kappa]3^2 \[Omega]^2;
\[Zeta]3=Sqrt[arg\[Zeta]3];
\[Psi]p3 =-\[Eta]3+\[Zeta]3;
\[Psi]m3 =\[Eta]3+\[Zeta]3;
B3=( -\[Omega]^2(1-E^(-\[Zeta]3  \[Tau])))/(\[Psi]m3+\[Psi]p3 E^(-\[Zeta]3  \[Tau]));
A=-(( \[Theta]v1 \[Lambda]v1 (\[Tau] \[Psi]p1+2 Log[(\[Psi]m1+E^(-\[Zeta]1 \[Tau]) \[Psi]p1)/(2\[Zeta]1)]))/ (\[Kappa]1^2)   )-( \[Theta]v2 \[Lambda]v2 (\[Tau] \[Psi]p2+2 Log[(\[Psi]m2+E^(-\[Zeta]2 \[Tau]) \[Psi]p2)/(2\[Zeta]2)]))/ (\[Kappa]2^2)   -( \[Theta]v3 \[Lambda]v3 (\[Tau] \[Psi]p3+2 Log[(\[Psi]m3+E^(-\[Zeta]3 \[Tau]) \[Psi]p3)/(2\[Zeta]3)]))/ (\[Kappa]3^2)   ;
If[Re[A+B1 V1+B2 V2+B3 V3]<-100,0,
E^(A+B1 V1+B2 V2+B3 V3)]
]


(* ::Input::Initialization:: *)
NormalHestonFondamentalTransformLog[\[Rho]_,\[Lambda]_,L_,\[Nu]_,V_,\[Omega]_,\[Tau]_]:=Module[{\[Zeta],\[Psi]p ,\[Psi]m,A,B,arg\[Zeta],\[Eta]},
\[Eta]=\[Lambda]+\[Rho] \[Nu] I \[Omega];
arg\[Zeta]=\[Eta]^2+\[Nu]^2 \[Omega]^2;
\[Zeta]=Sqrt[arg\[Zeta]];
\[Psi]p =-\[Eta]+\[Zeta];
\[Psi]m =\[Eta]+\[Zeta];
A=-(( L \[Lambda] (\[Tau] \[Psi]p+2 Log[(\[Psi]m+E^(-\[Zeta] \[Tau]) \[Psi]p)/(2\[Zeta])]))/ (\[Nu]^2)   );
B=( -\[Omega]^2(1-E^(-\[Zeta]  \[Tau])))/(\[Psi]m+\[Psi]p E^(-\[Zeta]  \[Tau]));
(A+B) V]


(* ::Input::Initialization:: *)
DerivativeNormalHestonFondamentalTransform[\[Rho]_,\[Lambda]_,L_,\[Nu]_,V_,\[Omega]_,\[Tau]_]:=Module[{\[Nu]\[Omega],\[Lambda]2,\[Rho]2,val,\[Zeta],\[Psi]p ,\[Psi]m,A,B,arg\[Zeta],\[Eta],DV,D\[Nu],D\[Rho],K,M,J,s,s1,H,M1,M2,s2,W},
\[Eta]=\[Lambda]+\[Rho] \[Nu] I \[Omega];
arg\[Zeta]=\[Eta]^2+\[Nu]^2 \[Omega]^2;
\[Zeta]=Sqrt[arg\[Zeta]];
\[Psi]p =-\[Eta]+\[Zeta];
\[Psi]m =\[Eta]+\[Zeta];
J=(\[Nu] \[Omega]^2+ I \[Rho] \[Omega] \[Eta])/ \[Zeta];K=\[Psi]m+E^(-\[Tau] \[Zeta]) \[Psi]p;M=-I \[Rho] \[Omega]+J;s=E^(\[Zeta] \[Tau]);s1=1/s;s2=s^2;H=2Log[K/(2\[Zeta])];M1=I+\[Nu] \[Rho] \[Tau] \[Omega];M2=-I+\[Nu] \[Rho] \[Tau] \[Omega];
A=-(( L \[Lambda] (\[Tau] \[Psi]p+ H))/ (\[Nu]^2)   );
B=( -\[Omega]^2(1-s1))/(\[Psi]m+\[Psi]p s1);
DV=(A+B);
val=Exp[DV V];\[Nu]\[Omega]=\[Nu] \[Omega];\[Lambda]2=\[Lambda]^2;\[Rho]2=\[Rho]^2;W=\[Zeta]((1+s) \[Zeta]+(-1+s) \[Eta]);
D\[Nu]=V (-((s1 J \[Tau] \[Omega]^2)/K)+(s1^2 (-1+s) \[Omega]^2 (M-J \[Tau] \[Psi]p+s (J+I \[Rho] \[Omega])))/K^2-(s1 L \[Lambda] (2 \[Zeta] (M-J \[Tau] \[Psi]p)+s (-2 J K+2 J \[Zeta]+K M \[Zeta] \[Tau]+2 I \[Zeta] \[Rho] \[Omega])))/(K \[Zeta] \[Nu]^2)+(2 L \[Lambda] (\[Tau] \[Psi]p+ H))/\[Nu]^3);
D\[Rho]=-(V \[Nu]\[Omega] \[Omega]^2 (-I (2 s (-1+L)+L+s2 L) \[Lambda] \[Lambda]2 \[Tau]+\[Lambda] \[Nu]\[Omega] (-2 (-1+s)^2 (-1+L) \[Rho]-I (2 s (-1+L)+L+s2 L) \[Nu]\[Omega] \[Tau] +I (2 s (-3+L)+L+s2 L) \[Nu]\[Omega] \[Rho]2 \[Tau] )+\[Nu]\[Omega]^2 (-1+\[Rho]2)  (I+I s2+2 s M2)+\[Lambda]2 (-I+2 L M1+s (2 I-6 \[Nu]\[Omega] \[Rho] \[Tau] +4 L M2)+s2 (-I+2 L M1))+(-1+s2)\[Zeta] (-I L \[Lambda]2 \[Tau]+\[Nu]\[Omega] \[Rho] +\[Lambda] (-I+L (2 I+\[Nu]\[Omega] \[Rho] \[Tau])))))/( W^2);
{val,val DV,val D\[Rho],val D\[Nu]} ]


(* ::Input::Initialization:: *)
DerivativeNormalHestonFondamentalTransform[\[Rho]_,\[Lambda]_,L_,\[Nu]_,V_,\[Omega]_,\[Tau]_,flag_]:=
Module[{\[Nu]\[Omega],\[Lambda]2,\[Rho]2,val,\[Zeta],\[Psi]p ,\[Psi]m,A,B,arg\[Zeta],\[Eta],DV,D\[Nu],D\[Rho],K,M,J,s,s1,H,M1,M2,s2,W},
If[flag==0,
\[Eta]=\[Lambda]+\[Rho] \[Nu] I \[Omega];
arg\[Zeta]=\[Eta]^2+\[Nu]^2 \[Omega]^2;
\[Zeta]=Sqrt[arg\[Zeta]];
\[Psi]p =-\[Eta]+\[Zeta];
\[Psi]m =\[Eta]+\[Zeta];
J=(\[Nu] \[Omega]^2+ I \[Rho] \[Omega] \[Eta])/ \[Zeta];K=\[Psi]m+E^(-\[Tau] \[Zeta]) \[Psi]p;M=-I \[Rho] \[Omega]+J;s=E^(\[Zeta] \[Tau]);s1=1/s;H=2Log[K/(2\[Zeta])];
A=-(( L \[Lambda] (\[Tau] \[Psi]p+ H))/ (\[Nu]^2)   );
B=( -\[Omega]^2(1-s1))/(\[Psi]m+\[Psi]p s1);
DV=(A+B);
val=Exp[DV V];
{val} ,
If[flag==2,
\[Eta]=\[Lambda]+\[Rho] \[Nu] I \[Omega];
arg\[Zeta]=\[Eta]^2+\[Nu]^2 \[Omega]^2;
\[Zeta]=Sqrt[arg\[Zeta]];
\[Psi]p =-\[Eta]+\[Zeta];
\[Psi]m =\[Eta]+\[Zeta];
J=(\[Nu] \[Omega]^2+ I \[Rho] \[Omega] \[Eta])/ \[Zeta];K=\[Psi]m+E^(-\[Tau] \[Zeta]) \[Psi]p;M=-I \[Rho] \[Omega]+J;s=E^(\[Zeta] \[Tau]);s1=1/s;s2=s^2;H=2Log[K/(2\[Zeta])];M1=I+\[Nu] \[Rho] \[Tau] \[Omega];M2=-I+\[Nu] \[Rho] \[Tau] \[Omega];
A=-(( L \[Lambda] (\[Tau] \[Psi]p+ H))/ (\[Nu]^2)   );
B=( -\[Omega]^2(1-s1))/(\[Psi]m+\[Psi]p s1);
DV=(A+B);
val=Exp[DV V];\[Nu]\[Omega]=\[Nu] \[Omega];\[Lambda]2=\[Lambda]^2;\[Rho]2=\[Rho]^2;W=\[Zeta]((1+s) \[Zeta]+(-1+s) \[Eta]);
D\[Nu]=V (-((s1 J \[Tau] \[Omega]^2)/K)+(s1^2 (-1+s) \[Omega]^2 (M-J \[Tau] \[Psi]p+s (J+I \[Rho] \[Omega])))/K^2-(s1 L \[Lambda] (2 \[Zeta] (M-J \[Tau] \[Psi]p)+s (-2 J K+2 J \[Zeta]+K M \[Zeta] \[Tau]+2 I \[Zeta] \[Rho] \[Omega])))/(K \[Zeta] \[Nu]^2)+(2 L \[Lambda] (\[Tau] \[Psi]p+ H))/\[Nu]^3);
D\[Rho]=-(V \[Nu]\[Omega] \[Omega]^2 (-I (2 s (-1+L)+L+s2 L) \[Lambda] \[Lambda]2 \[Tau]+\[Lambda] \[Nu]\[Omega] (-2 (-1+s)^2 (-1+L) \[Rho]-I (2 s (-1+L)+L+s2 L) \[Nu]\[Omega] \[Tau] +I (2 s (-3+L)+L+s2 L) \[Nu]\[Omega] \[Rho]2 \[Tau] )+\[Nu]\[Omega]^2 (-1+\[Rho]2)  (I+I s2+2 s M2)+\[Lambda]2 (-I+2 L M1+s (2 I-6 \[Nu]\[Omega] \[Rho] \[Tau] +4 L M2)+s2 (-I+2 L M1))+(-1+s2)\[Zeta] (-I L \[Lambda]2 \[Tau]+\[Nu]\[Omega] \[Rho] +\[Lambda] (-I+L (2 I+\[Nu]\[Omega] \[Rho] \[Tau])))))/( W^2);
{val,val DV,val D\[Rho],val D\[Nu]} ]]]



(* ::Input::Initialization:: *)
DerivativeNormalHestonCallIntegrand[\[Rho]_,\[Lambda]_,L_,\[Nu]_,V0_,S0_,K_List,T_,\[Omega]_]:=Re[-E^(-I \[Omega]  S0) Outer[Times,DerivativeNormalHestonFondamentalTransform[\[Rho],\[Lambda],L,\[Nu],V0,\[Omega],T],Table[Exp[I*K[[i]]\[Omega]]/\[Omega]^2,{i,1,Length[K]}]]]


(* ::Input::Initialization:: *)
DerivativeNormalHestonCallIntegrand[\[Rho]_,\[Lambda]_,L_,\[Nu]_,V0_,S0_,K_List,T_,\[Omega]_,flag_]:=Re[-E^(-I \[Omega]  S0) Outer[Times,DerivativeNormalHestonFondamentalTransform[\[Rho],\[Lambda],L,\[Nu],V0,\[Omega],T,flag],Table[Exp[I*K[[i]]\[Omega]]/\[Omega]^2,{i,1,Length[K]}]]]


(* ::Input::Initialization:: *)
DerivativeHestonNormalCallAux[\[Rho]_,\[Lambda]_,LT_,\[Nu]_,V_,S0_,k_,T_,nbsteps_,scale_,microratio_]:=Module[{res,\[Lambda]s=NormalHestonOptimalShift[\[Lambda],\[Rho],\[Nu]],LegendreCoef0,LegendreCoefn,period0,periodn,\[Epsilon],imax,initialperiod,LegendreCoefn2,\[Omega]},
\[Lambda]s=0.15;LegendreCoef0=LegendreCoeffs[nbsteps];LegendreCoefn=LegendreCoeffs[Floor[nbsteps/7]];
period0=scale;periodn=scale/5;\[Epsilon]=10^(-10);imax=1000;initialperiod=scale/microratio;
LegendreCoefn2=LegendreCoeffs[nbsteps];
res=Re[MatrixAdaptativeIntegrate[Function[\[Omega],DerivativeNormalHestonCallIntegrand[\[Rho],\[Lambda],LT,\[Nu],V,S0,k,T,\[Omega] +\[Lambda]s I]],LegendreCoef0,LegendreCoefn,
period0,periodn,\[Epsilon],imax,initialperiod,LegendreCoefn2]];
{res[[1]],1/\[Pi] res[[2]]}]


(* ::Input::Initialization:: *)
DerivativeHestonNormalCallAux[\[Rho]_,\[Lambda]_,LT_,\[Nu]_,V_,S0_,k_,T_,nbsteps_,scale_,microratio_,flag_]:=Module[{res,\[Lambda]s=NormalHestonOptimalShift[\[Lambda],\[Rho],\[Nu]],LegendreCoef0,LegendreCoefn,period0,periodn,\[Epsilon],imax,initialperiod,LegendreCoefn2,\[Omega]},
\[Lambda]s=0.15;LegendreCoef0=LegendreCoeffs[nbsteps];LegendreCoefn=LegendreCoeffs[Floor[nbsteps/7]];
period0=scale;periodn=scale/5;\[Epsilon]=10^(-10);imax=1000;initialperiod=scale/microratio;
LegendreCoefn2=LegendreCoeffs[nbsteps];
res=Re[MatrixAdaptativeIntegrate[Function[\[Omega],DerivativeNormalHestonCallIntegrand[\[Rho],\[Lambda],LT,\[Nu],V,S0,k,T,\[Omega] +\[Lambda]s I,flag]],LegendreCoef0,LegendreCoefn,
period0,periodn,\[Epsilon],imax,initialperiod,LegendreCoefn2]];
{res[[1]],1/\[Pi] res[[2]]}]


(* ::Input::Initialization:: *)
DerivativeHestonNormalCall[\[Rho]_,\[Lambda]_,LT_,\[Nu]1_,V01_,S1_,k1_List,T_,nbsteps_,scale_,microratio_]:=
Module[{optlist,L,\[Nu],V0,F,k},
L=1/Sqrt[V01];\[Nu]=L \[Nu]1;V0=1.;F=L S1;k=Table[k1[[i]] L,{i,1,Length[k1]}];
optlist=DerivativeHestonNormalCallAux[\[Rho],\[Lambda],LT,\[Nu],V0,F,k,T,nbsteps,scale,microratio];
{Table[Max[{optlist[[2,1,i]]/L,S1-k1[[i]],1.`*^-12}],{i,1,Length[optlist[[2,1]]]}],
Table[optlist[[2,2,i]] L,{i,1,Length[optlist[[2,2]]]}],
Table[optlist[[2,3,i]]/L,{i,1,Length[optlist[[2,3]]]}],
Table[optlist[[2,4,i]],{i,1,Length[optlist[[2,4]]]}]}
]



(* ::Input::Initialization:: *)
DerivativeHestonNormalCall[\[Rho]_,\[Lambda]_,LT_,\[Nu]1_,V01_,S1_,k1_List,T_,nbsteps_,scale_,microratio_,flag_]:=
Module[{optlist,L,\[Nu],V0,F,k},
L=1/Sqrt[V01];\[Nu]=L \[Nu]1;V0=1.;F=L S1;k=Table[k1[[i]] L,{i,1,Length[k1]}];
optlist=DerivativeHestonNormalCallAux[\[Rho],\[Lambda],LT,\[Nu],V0,F,k,T,nbsteps,scale,microratio,flag];
If[flag==0,
{Table[Max[{optlist[[2,1,i]]/L,S1-k1[[i]],1.`*^-12}],{i,1,Length[optlist[[2,1]]]}]},
{Table[Max[{optlist[[2,1,i]]/L,S1-k1[[i]],1.`*^-12}],{i,1,Length[optlist[[2,1]]]}],
Table[optlist[[2,2,i]] L,{i,1,Length[optlist[[2,2]]]}],
Table[optlist[[2,3,i]]/L,{i,1,Length[optlist[[2,3]]]}],
Table[optlist[[2,4,i]],{i,1,Length[optlist[[2,4]]]}]}
]]



(* ::Input::Initialization:: *)
DerKDerivativeNormalHestonCallIntegrand[\[Rho]_,\[Lambda]_,L_,\[Nu]_,V0_,S0_,K_List,T_,\[Omega]_]:=Re[-E^(-I \[Omega]  S0) Outer[Times,DerivativeNormalHestonFondamentalTransform[\[Rho],\[Lambda],L,\[Nu],V0,\[Omega],T],Table[I Exp[I*K[[i]]\[Omega]]/\[Omega],{i,1,Length[K]}]]]


(* ::Input::Initialization:: *)
DerKDerivativeNormalHestonCallIntegrand[\[Rho]_,\[Lambda]_,L_,\[Nu]_,V0_,S0_,K_List,T_,\[Omega]_,flag_]:=Re[-E^(-I \[Omega]  S0) Outer[Times,DerivativeNormalHestonFondamentalTransform[\[Rho],\[Lambda],L,\[Nu],V0,\[Omega],T,flag],Table[I Exp[I*K[[i]]\[Omega]]/\[Omega],{i,1,Length[K]}]]]


(* ::Input::Initialization:: *)
DerKDerivativeHestonNormalCallAux[\[Rho]_,\[Lambda]_,LT_,\[Nu]_,V_,S0_,k_,T_,nbsteps_,scale_,microratio_]:=Module[{res,\[Lambda]s=NormalHestonOptimalShift[\[Lambda],\[Rho],\[Nu]],LegendreCoef0,LegendreCoefn,period0,periodn,\[Epsilon],imax,initialperiod,LegendreCoefn2,\[Omega]},
\[Lambda]s=0.15;LegendreCoef0=LegendreCoeffs[nbsteps];LegendreCoefn=LegendreCoeffs[Floor[nbsteps/7]];
period0=scale;periodn=scale/5;\[Epsilon]=10^(-10);imax=1000;initialperiod=scale/microratio;
LegendreCoefn2=LegendreCoeffs[nbsteps];
res=Re[MatrixAdaptativeIntegrate[Function[\[Omega],DerKDerivativeNormalHestonCallIntegrand[\[Rho],\[Lambda],LT,\[Nu],V,S0,k,T,\[Omega] +\[Lambda]s I]],LegendreCoef0,LegendreCoefn,
period0,periodn,\[Epsilon],imax,initialperiod,LegendreCoefn2]];
{res[[1]],1/\[Pi] res[[2]]}]


(* ::Input::Initialization:: *)
DerKDerivativeHestonNormalCallAux[\[Rho]_,\[Lambda]_,LT_,\[Nu]_,V_,S0_,k_,T_,nbsteps_,scale_,microratio_,flag_]:=Module[{res,\[Lambda]s=NormalHestonOptimalShift[\[Lambda],\[Rho],\[Nu]],LegendreCoef0,LegendreCoefn,period0,periodn,\[Epsilon],imax,initialperiod,LegendreCoefn2,\[Omega]},
\[Lambda]s=0.15;LegendreCoef0=LegendreCoeffs[nbsteps];LegendreCoefn=LegendreCoeffs[Floor[nbsteps/7]];
period0=scale;periodn=scale/5;\[Epsilon]=10^(-10);imax=1000;initialperiod=scale/microratio;
LegendreCoefn2=LegendreCoeffs[nbsteps];
res=Re[MatrixAdaptativeIntegrate[Function[\[Omega],DerKDerivativeNormalHestonCallIntegrand[\[Rho],\[Lambda],LT,\[Nu],V,S0,k,T,\[Omega] +\[Lambda]s I,flag]],LegendreCoef0,LegendreCoefn,
period0,periodn,\[Epsilon],imax,initialperiod,LegendreCoefn2]];
{res[[1]],1/\[Pi] res[[2]]}]


(* ::Input::Initialization:: *)
DerKDerivativeHestonNormalCall[\[Rho]_,\[Lambda]_,LT_,\[Nu]1_,V01_,S1_,k1_List,T_,nbsteps_,scale_,microratio_]:=
Module[{optlist,L,\[Nu],V0,F,k},
L=1/Sqrt[V01];\[Nu]=L \[Nu]1;V0=1.;F=L S1;k=Table[k1[[i]] L,{i,1,Length[k1]}];
optlist=DerKDerivativeHestonNormalCallAux[\[Rho],\[Lambda],LT,\[Nu],V0,F,k,T,nbsteps,scale,microratio];
{Table[Max[{optlist[[2,1,i]]/L,S1-k1[[i]],1.`*^-12}],{i,1,Length[optlist[[2,1]]]}],
Table[optlist[[2,2,i]] L,{i,1,Length[optlist[[2,2]]]}],
Table[optlist[[2,3,i]]/L,{i,1,Length[optlist[[2,3]]]}],
Table[optlist[[2,4,i]],{i,1,Length[optlist[[2,4]]]}]}
]



(* ::Input::Initialization:: *)
DerKDerivativeHestonNormalCall[\[Rho]_,\[Lambda]_,LT_,\[Nu]1_,V01_,S1_,k1_List,T_,nbsteps_,scale_,microratio_,flag_]:=
Module[{optlist,L,\[Nu],V0,F,k},
L=1/Sqrt[V01];\[Nu]=L \[Nu]1;V0=1.;F=L S1;k=Table[k1[[i]] L,{i,1,Length[k1]}];
optlist=DerKDerivativeHestonNormalCallAux[\[Rho],\[Lambda],LT,\[Nu],V0,F,k,T,nbsteps,scale,microratio,flag];
If[flag==0,
{Table[Max[{optlist[[2,1,i]]/L,S1-k1[[i]],1.`*^-12}],{i,1,Length[optlist[[2,1]]]}]},
{Table[Max[{optlist[[2,1,i]]/L,S1-k1[[i]],1.`*^-12}],{i,1,Length[optlist[[2,1]]]}],
Table[optlist[[2,2,i]] L,{i,1,Length[optlist[[2,2]]]}],
Table[optlist[[2,3,i]]/L,{i,1,Length[optlist[[2,3]]]}],
Table[optlist[[2,4,i]],{i,1,Length[optlist[[2,4]]]}]}
]]



(* ::Input::Initialization:: *)
NormalHestonSmileCalibrate[KList_,PriceList_,WeightList_,S0_,\[Lambda]_,LT_,T_,nbsteps_,scale_,microratio_]:=Module[{func,gradfunc,V0,rho,nu},
func=Function[{V,\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[\[Rho],\[Lambda],LT,\[Nu],V,S0,KList,T,nbsteps,scale,microratio,0]},
Sum[WeightList[[i]](PriceList[[i]]-ff[[1,i]])^2,{i,1,Length[KList]}]]];
gradfunc=Function[{V,\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[\[Rho],\[Lambda],LT,\[Nu],V,S0,KList,T,nbsteps,scale,microratio]},
{Sum[WeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[2,i]],{i,1,Length[KList]}],
Sum[WeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[3,i]],{i,1,Length[KList]}],
Sum[WeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[4,i]],{i,1,Length[KList]}]
}]];
FindMinimum[func[V0,rho,nu],{{V0,0.00003,0.000001,0.001},{nu,0.001,0.000001,0.01},{rho,0,-0.9,0.9}},
MaxIterations->200,AccuracyGoal->8,Method->"LevenbergMarquardt",
Gradient->gradfunc[V0,rho,nu]] 
]



(* ::Input::Initialization:: *)
NormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,S0_,K_,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  S0) NormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Omega],T]NormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]]]


(* ::Input::Initialization:: *)
NormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,S0_,K_List,T_,\[Omega]_]:=Re[E^(-I \[Omega]  S0) NormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Omega],T]Table[NormalCallPayOffFourierTransform[K[[i]],\[Omega]],{i,1,Length[K]}]]


(* ::Input::Initialization:: *)
NormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,K_,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  S0) NormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Omega],T]NormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]]]


(* ::Input::Initialization:: *)
NormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,K_,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  S0) NormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Omega],T]NormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]]]


(* ::Input::Initialization:: *)
NormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,S0_,K_List,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  S0) NormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Omega],T]Table[NormalCallPayOffFourierTransform[K[[i]],\[Alpha],a,\[Omega]],{i,1,Length[K]}]]


(* ::Input::Initialization:: *)
NormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,K_List,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  S0) NormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Omega],T]Table[NormalCallPayOffFourierTransform[K[[i]],\[Alpha],a,\[Omega]],{i,1,Length[K]}]]


(* ::Input::Initialization:: *)
NormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,K_List,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  S0) NormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Omega],T]Table[NormalCallPayOffFourierTransform[K[[i]],\[Alpha],a,\[Omega]],{i,1,Length[K]}]]


(* ::Input::Initialization:: *)
NormalHestonShiftDiscriminator[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,\[Tau]_,\[Lambda]_]:=(\[Lambda]v-\[Rho] \[Kappa] \[Lambda])+Sqrt[(\[Lambda]v-\[Rho] \[Kappa] \[Lambda])^2-\[Kappa]^2 \[Lambda]^2]+(-(\[Lambda]v-\[Rho] \[Kappa] \[Lambda])+Sqrt[(\[Lambda]v-\[Rho] \[Kappa] \[Lambda])^2-\[Kappa]^2 \[Lambda]^2])E^(-Sqrt[(\[Lambda]v-\[Rho] \[Kappa] \[Lambda])^2-\[Kappa]^2 \[Lambda]^2] \[Tau])


(* ::Input::Initialization:: *)
NormalHestonOptimalShift[\[Lambda]v_,\[Rho]_,\[Kappa]_]:=Min[0.5, (\[Lambda]v(1-\[Rho]^2/2))/(2\[Kappa] )] 


(* ::Input::Initialization:: *)
HestonNormalCallN[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
NIntegrate[NormalHestonCallIntegrand[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,1,1,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
HestonNormalCallN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,T_]:=1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
NIntegrate[NormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,k,1,1,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
HestonNormalCallN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,T_]:=1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
NIntegrate[NormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,k,1,1,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
HestonNormalCallAux[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=1/\[Pi] Re[Module[{\[Lambda]=NormalHestonOptimalShift[\[Lambda]v,\[Rho],\[Kappa]],\[Omega]},
AdaptativeIntegrate[Function[\[Omega],NormalHestonCallIntegrand[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,1,1,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[8],
20\[Lambda],3\[Lambda],10^(-10),1000,2\[Lambda],LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
HestonNormalCallAux[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_List,T_]:=1/\[Pi] Re[Module[{\[Lambda]=NormalHestonOptimalShift[\[Lambda]v,\[Rho],\[Kappa]],\[Omega]},
AdaptativeIntegrate[Function[\[Omega],NormalHestonCallIntegrand[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[8],
20\[Lambda],3\[Lambda],10^(-10),1000,2\[Lambda],LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
HestonNormalCallAux[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,T_]:=1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],NormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,k,1,1,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
HestonNormalCallAux[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,T_]:=1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],NormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,k,1,1,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
HestonNormalCall[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=Module[{\[Theta]v1,\[Kappa]1,V1,S01,k1,L},
L=Sqrt[1./V];\[Theta]v1=L^2 \[Theta]v;\[Kappa]1=L \[Kappa];V1=1.0;S01=L S0;k1=L k;
HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1,V1,S01,k1,T]/L
]


(* ::Input::Initialization:: *)
HestonNormalCall[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_List,T_]:=Module[{\[Theta]v1,\[Kappa]1,V1,S01,k1,L},
L=Sqrt[1./V];\[Theta]v1=L^2 \[Theta]v;\[Kappa]1=L \[Kappa];V1=1.0;S01=L S0;k1=L k;
HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1,V1,S01,k1,T]/L
]


(* ::Input::Initialization:: *)
HestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,T_]:=Module[{\[Theta]v1a,\[Kappa]1a,V1a,\[Theta]v2a,\[Kappa]2a,V2a,S0a,ka,L},
L=Sqrt[1./(V1+V2)];\[Theta]v1a=L^2 \[Theta]v1;\[Theta]v2a=L^2 \[Theta]v2;\[Kappa]1a=L \[Kappa]1;\[Kappa]2a=L \[Kappa]2;V1a=L^2 V1;V2a=L^2 V2;S0a=L S0;ka=L k;
HestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1a,\[Kappa]1a,V1a,\[Rho]2,\[Lambda]v2,\[Theta]v2a,\[Kappa]2a,V2a,S0,ka,T]/L
]


(* ::Input::Initialization:: *)
HestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,T_]:=Module[{\[Theta]v1a,\[Kappa]1a,V1a,\[Theta]v2a,\[Kappa]2a,V2a,\[Theta]v3a,\[Kappa]3a,V3a,S0a,ka,L},
L=Sqrt[1./(V1+V2+V3)];\[Theta]v1a=L^2 \[Theta]v1;\[Theta]v2a=L^2 \[Theta]v2;\[Theta]v3a=L^2 \[Theta]v3;\[Kappa]1a=L \[Kappa]1;\[Kappa]2a=L \[Kappa]2;\[Kappa]3a=L \[Kappa]3;V1a=L^2 V1;V2a=L^2 V2;V3a=L^2 V3;S0a=L S0;ka=L k;
HestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1a,\[Kappa]1a,V1a,\[Rho]2,\[Lambda]v2,\[Theta]v2a,\[Kappa]2a,V2a,\[Rho]3,\[Lambda]v3,\[Theta]v3a,\[Kappa]3a,V3a,S0,ka,T]/L
]


(* ::Input::Initialization:: *)
HestonNormalCallTrace[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=Module[{\[Theta]va,\[Kappa]a,Va,S0a,ka,L},
L=Sqrt[1./V];\[Theta]va=L^2 \[Theta]v;\[Kappa]a=L \[Kappa];Va=L^2 V;S0a=L S0;ka=L k;Print["L=",L," \[Kappa]a=",\[Kappa]a," S0a=",S0a," ka=",ka];
HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]va,\[Kappa]a,Va,S0a,ka,T]/L
]


(* ::Input::Initialization:: *)
HestonNormalCallTrace[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_List,T_]:=Module[{\[Theta]va,\[Kappa]a,Va,S0a,ka,L},
L=Sqrt[1./V];\[Theta]va=L^2 \[Theta]v;\[Kappa]a=L \[Kappa];Va=L^2 V;S0a=L S0;ka=L k;Print["L=",L," \[Kappa]a=",\[Kappa]a," S0a=",S0a," ka=",ka];
(HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]va,\[Kappa]a,Va,S0a,#,T]/L)& /@ ka
]


(* ::Input::Initialization:: *)
HestonNormalCallTrace[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,T_]:=Module[{\[Theta]v1a,\[Kappa]1a,V1a,S0a,ka,\[Theta]v2a,\[Kappa]2a,V2a,L},
L=Sqrt[1./(V1+V2)];\[Theta]v1a=L^2 \[Theta]v1;\[Theta]v2a=L^2 \[Theta]v2;\[Kappa]1a=L \[Kappa]1;\[Kappa]2a=L \[Kappa]2;V1a=L^2 V1;V2a=L^2 V2;S0a=L S0;ka=L k;Print["L=",L," V1a=",V1a," \[Kappa]a1=",\[Kappa]1a," V2a=",V2a," \[Kappa]a2=",\[Kappa]2a," S0a=",S0a," ka=",ka];
HestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1a,\[Kappa]1a,V1a,\[Rho]2,\[Lambda]v2,\[Theta]v2a,\[Kappa]2a,V2a,S0a,ka,T]/L
]


(* ::Input::Initialization:: *)
HestonNormalCallTrace[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,T_]:=Module[{\[Theta]v1a,\[Kappa]1a,V1a,S0a,ka,\[Theta]v2a,\[Kappa]2a,V2a,L},
L=Sqrt[1./(V1+V2)];\[Theta]v1a=L^2 \[Theta]v1;\[Theta]v2a=L^2 \[Theta]v2;\[Kappa]1a=L \[Kappa]1;\[Kappa]2a=L \[Kappa]2;V1a=L^2 V1;V2a=L^2 V2;S0a=L S0;ka=L k;Print["L=",L," V1a=",V1a," \[Kappa]a1=",\[Kappa]1a," V2a=",V2a," \[Kappa]a2=",\[Kappa]2a," S0a=",S0a," ka=",ka];
(HestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1a,\[Kappa]1a,V1a,\[Rho]2,\[Lambda]v2,\[Theta]v2a,\[Kappa]2a,V2a,S0a,#,T]/L)& /@ ka
]


(* ::Input::Initialization:: *)
HestonNormalCallTrace[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,T_]:=Module[{\[Theta]v1a,\[Kappa]1a,V1a,\[Theta]v3a,\[Kappa]3a,V3a,S0a,ka,\[Theta]v2a,\[Kappa]2a,V2a,L},
L=Sqrt[1./(V1+V2+V3)];\[Theta]v1a=L^2 \[Theta]v1;\[Theta]v2a=L^2 \[Theta]v2;\[Theta]v3a=L^2 \[Theta]v3;\[Kappa]1a=L \[Kappa]1;\[Kappa]2a=L \[Kappa]2;\[Kappa]3a=L \[Kappa]3;V1a=L^2 V1;V2a=L^2 V2;V3a=L^2 V3;S0a=L S0;ka=L k;Print["L=",L," V1a=",V1a," \[Kappa]a1=",\[Kappa]1a," V2a=",V2a," \[Kappa]a2=",\[Kappa]2a," V3a=",V3a," \[Kappa]a3=",\[Kappa]3a," S0a=",S0a," ka=",ka];
HestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1a,\[Kappa]1a,V1a,\[Rho]2,\[Lambda]v2,\[Theta]v2a,\[Kappa]2a,V2a,S0a,ka,T]/L
]


(* ::Input::Initialization:: *)
HestonNormalCallTrace[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,T_]:=Module[{\[Theta]v1a,\[Kappa]1a,V1a,\[Theta]v3a,\[Kappa]3a,V3a,S0a,ka,\[Theta]v2a,\[Kappa]2a,V2a,L},
L=Sqrt[1./(V1+V2+V3)];\[Theta]v1a=L^2 \[Theta]v1;\[Theta]v2a=L^2 \[Theta]v2;\[Theta]v3a=L^2 \[Theta]v3;\[Kappa]1a=L \[Kappa]1;\[Kappa]2a=L \[Kappa]2;\[Kappa]3a=L \[Kappa]3;V1a=L^2 V1;V2a=L^2 V2;V3a=L^2 V3;S0a=L S0;ka=L k;Print["L=",L," V1a=",V1a," \[Kappa]a1=",\[Kappa]1a," V2a=",V2a," \[Kappa]a2=",\[Kappa]2a," V3a=",V3a," \[Kappa]a3=",\[Kappa]3a," S0a=",S0a," ka=",ka];
(HestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1a,\[Kappa]1a,V1a,\[Rho]2,\[Lambda]v2,\[Theta]v2a,\[Kappa]2a,V2a,S0a,#,T]/L)& /@ ka
]


(* ::Input::Initialization:: *)
ThInterpolator[x1_,y1_,x2_,y2_,x_]:=Module[{a},
a=ArcTanh[1-y2/y1]/(x2-x1);
y1(1-Tanh[a(x-y1)])]


(* ::Input::Initialization:: *)
LinInterpolator[x1_,y1_,x2_,y2_,x_]:=Module[{a},
a=(y2-y1)/(x2-x1);
y2+a(x-x2)]


(* ::Input::Initialization:: *)
QuadInterpolator[x1_,y1_,x2_,y2_,x3_,y3_,x_]:=Module[{a,b},
a=-((x2 y1-x3 y1-x1 y2+x3 y2+x1 y3-x2 y3)/((x1-x2) (x1-x3) (-x2+x3)));
b=-((-2 x1 x2 y1+x2^2 y1+2 x1 x3 y1-x3^2 y1+x1^2 y2-2 x1 x3 y2+x3^2 y2-x1^2 y3+2 x1 x2 y3-x2^2 y3)/((x2-x3) (x1^2-x1 x2-x1 x3+x2 x3)));
a (x-x1)^2+b(x-x1)+y1]


(* ::Input::Initialization:: *)
PowerInterpolator[x1_,y1_,x2_,y2_,x3_,y3_,x_]:=Module[{a,b},
b=Log[(y3-y1)/(y2-y1)]/Log[(x3-x1)/(x2-x1)];
a=(y3-y1)/(x3-x1)^b;
y1+a (x-x1)^b
]



(* ::Input::Initialization:: *)
(* interpolateur qui interpole une variable >0 par exemple la vol implicite en fonction de la vol de vol *)


(* ::Input::Initialization:: *)
SmartInterpolator[x1_,y1_,x2_,y2_,x3_,y3_,x_]:=Module[{a1,a2},
a1=(y2-y1)/(x2-x1);a2=(y3-y2)/(x3-x2);
Which[
a1>0&&a2<0,LinInterpolator[x1,y1,x3,y3,x],
a1>0&&a2>=0,PowerInterpolator[x1,y1,x2,y2,x3,y3,x],
a1<0&&a2>0,LinInterpolator[x1,y1,x3,y3,x],
a1<0&&a2<=0&&a2>a1, PowerInterpolator[x1,y1,x2,y2,x3,y3,x],
a1<0&&a2<=0&&a2<=a1,ThInterpolator[x1,y1,x3,y3,x]
]]



(* ::Input::Initialization:: *)
TransHestonNormalCall[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_,LimitGindinkin_]:=Module[{\[Theta]v1,\[Kappa]1,V1,S01,k1,L,\[Kappa]1Limit,\[Kappa]1test1,\[Kappa]1test2,vol1,vol2,vol},
L=Sqrt[1./V];\[Theta]v1=L^2 \[Theta]v;\[Kappa]1=L \[Kappa];V1=1.0;S01=L S0;k1=L k;
\[Kappa]1Limit=LimitGindinkin Sqrt[2 \[Lambda]v \[Theta]v1];
If[\[Kappa]1<0.9 \[Kappa]1Limit,
HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1,V1,S01,k1,T]/L,
\[Kappa]1test1=0.8 \[Kappa]1Limit;
\[Kappa]1test2=0.9 \[Kappa]1Limit;
vol1=NormalImplicitVol[S01,k1,T,HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1test1,V1,S01,k1,T]];
vol2=NormalImplicitVol[S01,k1,T,HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1test2,V1,S01,k1,T]];
If[vol2<vol1,
vol=ThInterpolator[\[Kappa]1test1,vol1,\[Kappa]1test2,vol2,\[Kappa]1],
vol=LinInterpolator[\[Kappa]1test1,vol1,\[Kappa]1test2,vol2,\[Kappa]1]
];
NormalCall[S01,vol,k1,T]/L
]
]


(* ::Input::Initialization:: *)
TransHestonNormalCall[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_,LimitGindinkin_,order_]:=Module[{\[Theta]v1,\[Kappa]1,V1,S01,k1,L,\[Kappa]1Limit,\[Kappa]1test1,\[Kappa]1test2,\[Kappa]1test3,vol1,vol2,vol3,vol},
L=Sqrt[1./V];\[Theta]v1=L^2 \[Theta]v;\[Kappa]1=L \[Kappa];V1=1.0;S01=L S0;k1=L k;
\[Kappa]1Limit=LimitGindinkin Sqrt[2 \[Lambda]v \[Theta]v1];
Print["LimitGindinkin=",\[Kappa]1Limit," \[Kappa]1=",\[Kappa]1];
If[\[Kappa]1<0.9 \[Kappa]1Limit,
HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1,V1,S01,k1,T]/L,
If[order==1,
\[Kappa]1test1=0.8 \[Kappa]1Limit;
\[Kappa]1test2=0.9 \[Kappa]1Limit;
vol1=NormalImplicitVol[S01,k1,T,HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1test1,V1,S01,k1,T]];
vol2=NormalImplicitVol[S01,k1,T,HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1test2,V1,S01,k1,T]];
If[vol2<vol1,
vol=ThInterpolator[\[Kappa]1test1,vol1,\[Kappa]1test2,vol2,\[Kappa]1],
vol=LinInterpolator[\[Kappa]1test1,vol1,\[Kappa]1test2,vol2,\[Kappa]1]
]
];
If[order==2,
\[Kappa]1test1=0.8 \[Kappa]1Limit;
\[Kappa]1test2=0.85 \[Kappa]1Limit;
\[Kappa]1test3=0.9 \[Kappa]1Limit;
vol1=NormalImplicitVol[S01,k1,T,HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1test1,V1,S01,k1,T]];
vol2=NormalImplicitVol[S01,k1,T,HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1test2,V1,S01,k1,T]];
vol3=NormalImplicitVol[S01,k1,T,HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1test3,V1,S01,k1,T]];
Print["\[Kappa]1test1=",\[Kappa]1test1," \[Kappa]1test2=",\[Kappa]1test2," \[Kappa]1test3=",\[Kappa]1test3," vol1=",vol1," vol2=",vol2," vol3=",vol3];
vol=SmartInterpolator[\[Kappa]1test1,vol1,\[Kappa]1test2,vol2,\[Kappa]1test3,vol3,\[Kappa]1];
Print["vol=",vol]
];
NormalCall[S01,vol,k1,T]/L
]]


(* ::Input::Initialization:: *)
TransHestonNormalCall[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_List,T_,LimitGindinkin_]:=Module[{\[Theta]v1,\[Kappa]1,V1,S01,k1,L,\[Kappa]1Limit,\[Kappa]1test1,\[Kappa]1test2,vol1,vol2,vol},
L=Sqrt[1./V];\[Theta]v1=L^2 \[Theta]v;\[Kappa]1=L \[Kappa];V1=1.0;S01=L S0;k1=L k;
\[Kappa]1Limit=LimitGindinkin Sqrt[2 \[Lambda]v \[Theta]v1];
Table[
If[\[Kappa]1<0.9 \[Kappa]1Limit,
HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1,V1,S01,k1[[i]],T]/L,
\[Kappa]1test1=0.8 \[Kappa]1Limit;
\[Kappa]1test2=0.9 \[Kappa]1Limit;
vol1=NormalImplicitVol[S01,k1[[i]],T,HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1test1,V1,S01,k1[[i]],T]];
vol2=NormalImplicitVol[S01,k1[[i]],T,HestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1test2,V1,S01,k1[[i]],T]];
If[vol2<vol1,
vol=ThInterpolator[\[Kappa]1test1,vol1,\[Kappa]1test2,vol2,\[Kappa]1],
vol=LinInterpolator[\[Kappa]1test1,vol1,\[Kappa]1test2,vol2,\[Kappa]1]
];
NormalCall[S01,vol,k1[[i]],T]/L
],{i,1,Length[k]}]
]


(* ::Input::Initialization:: *)
TransHestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,T_]:=Module[{\[Theta]v1a,\[Kappa]1a,V1a,\[Theta]v2a,\[Kappa]2a,V2a,S0a,ka,L},
L=Sqrt[1./(V1+V2)];\[Theta]v1a=L^2 \[Theta]v1;\[Theta]v2a=L^2 \[Theta]v2;\[Kappa]1a=L \[Kappa]1;\[Kappa]2a=L \[Kappa]2;V1a=L^2 V1;V2a=L^2 V2;S0a=L S0;ka=L k;
HestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1a,\[Kappa]1a,V1a,\[Rho]2,\[Lambda]v2,\[Theta]v2a,\[Kappa]2a,V2a,S0,ka,T]/L
]


(* ::Input::Initialization:: *)
TransHestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_List,T_]:=Module[{\[Theta]v1a,\[Kappa]1a,V1a,\[Theta]v2a,\[Kappa]2a,V2a,S0a,ka,L},
L=Sqrt[1./(V1+V2)];\[Theta]v1a=L^2 \[Theta]v1;\[Theta]v2a=L^2 \[Theta]v2;\[Kappa]1a=L \[Kappa]1;\[Kappa]2a=L \[Kappa]2;V1a=L^2 V1;V2a=L^2 V2;S0a=L S0;ka=L k;
(HestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1a,\[Kappa]1a,V1a,\[Rho]2,\[Lambda]v2,\[Theta]v2a,\[Kappa]2a,V2a,S0,#,T]/L)& /@ ka
]


(* ::Input::Initialization:: *)
TransHestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,T_]:=Module[{\[Theta]v1a,\[Kappa]1a,V1a,\[Theta]v2a,\[Kappa]2a,V2a,\[Theta]v3a,\[Kappa]3a,V3a,S0a,ka,L},
L=Sqrt[1./(V1+V2+V3)];\[Theta]v1a=L^2 \[Theta]v1;\[Theta]v2a=L^2 \[Theta]v2;\[Theta]v3a=L^2 \[Theta]v3;\[Kappa]1a=L \[Kappa]1;\[Kappa]2a=L \[Kappa]2;\[Kappa]3a=L \[Kappa]3;V1a=L^2 V1;V2a=L^2 V2;V3a=L^2 V3;S0a=L S0;ka=L k;
HestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1a,\[Kappa]1a,V1a,\[Rho]2,\[Lambda]v2,\[Theta]v2a,\[Kappa]2a,V2a,\[Rho]3,\[Lambda]v3,\[Theta]v3a,\[Kappa]3a,V3a,S0,ka,T]/L
]


(* ::Input::Initialization:: *)
TransHestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_List,T_]:=Module[{\[Theta]v1a,\[Kappa]1a,V1a,\[Theta]v2a,\[Kappa]2a,V2a,\[Theta]v3a,\[Kappa]3a,V3a,S0a,ka,L},
L=Sqrt[1./(V1+V2+V3)];\[Theta]v1a=L^2 \[Theta]v1;\[Theta]v2a=L^2 \[Theta]v2;\[Theta]v3a=L^2 \[Theta]v3;\[Kappa]1a=L \[Kappa]1;\[Kappa]2a=L \[Kappa]2;\[Kappa]3a=L \[Kappa]3;V1a=L^2 V1;V2a=L^2 V2;V3a=L^2 V3;S0a=L S0;ka=L k;
(HestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1a,\[Kappa]1a,V1a,\[Rho]2,\[Lambda]v2,\[Theta]v2a,\[Kappa]2a,V2a,\[Rho]3,\[Lambda]v3,\[Theta]v3a,\[Kappa]3a,V3a,S0,#,T]/L)& /@ ka
]


(* ::Input::Initialization:: *)
LogNormalHestonFondamentalTransform[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,\[Omega]_,\[Tau]_]:=Module[{\[Zeta],\[Psi]p ,\[Psi]m,A,B,arg\[Zeta],\[Eta]},
\[Eta]=\[Lambda]v+\[Rho] \[Kappa] I \[Omega];
arg\[Zeta]=\[Eta]^2+\[Kappa]^2 (\[Omega]^2-I \[Omega]);
\[Zeta]=Sqrt[arg\[Zeta]];
\[Psi]p =-\[Eta]+\[Zeta];
\[Psi]m =\[Eta]+\[Zeta];
A=-(( \[Theta]v \[Lambda]v (\[Tau] \[Psi]p+2 Log[(\[Psi]m+E^(-\[Zeta] \[Tau]) \[Psi]p)/(2\[Zeta])]))/ (\[Kappa]^2)   );
B=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]  \[Tau])))/(\[Psi]m+\[Psi]p E^(-\[Zeta]  \[Tau]));
If[Re[A+B V]<-100,0,
E^(A+B V)]]


(* ::Input::Initialization:: *)
LogNormalHestonFondamentalTransform[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Omega]_,\[Tau]_]:=
Module[{\[Zeta]1,\[Psi]p1 ,\[Psi]m1,B1,arg\[Zeta]1,\[Eta]1,\[Zeta]2,\[Psi]p2 ,\[Psi]m2,A2,B2,arg\[Zeta]2,\[Eta]2,A},
\[Eta]1=\[Lambda]v1+\[Rho]1 \[Kappa]1 I \[Omega];
arg\[Zeta]1=\[Eta]1^2+\[Kappa]1^2 (\[Omega]^2-I \[Omega]);
\[Zeta]1=Sqrt[arg\[Zeta]1];
\[Psi]p1 =-\[Eta]1+\[Zeta]1;
\[Psi]m1 =\[Eta]1+\[Zeta]1;
B1=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]1  \[Tau])))/(\[Psi]m1+\[Psi]p1 E^(-\[Zeta]1  \[Tau]));
\[Eta]2=\[Lambda]v2+\[Rho]2 \[Kappa]2 I \[Omega];
arg\[Zeta]2=\[Eta]2^2+\[Kappa]2^2 (\[Omega]^2-I \[Omega]);
\[Zeta]2=Sqrt[arg\[Zeta]2];
\[Psi]p2 =-\[Eta]2+\[Zeta]2;
\[Psi]m2 =\[Eta]2+\[Zeta]2;
B2=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]2  \[Tau])))/(\[Psi]m2+\[Psi]p2 E^(-\[Zeta]2  \[Tau]));
A=-(( \[Theta]v1 \[Lambda]v1 (\[Tau] \[Psi]p1+2 Log[(\[Psi]m1+E^(-\[Zeta]1 \[Tau]) \[Psi]p1)/(2\[Zeta]1)]))/ (\[Kappa]1^2)   )-( \[Theta]v2 \[Lambda]v2 (\[Tau] \[Psi]p2+2 Log[(\[Psi]m2+E^(-\[Zeta]2 \[Tau]) \[Psi]p2)/(2\[Zeta]2)]))/ (\[Kappa]2^2)   ;
If[Re[A+B1 V1+B2 V2]<-100,0,
E^(A+B1 V1+B2 V2)]
]


(* ::Input::Initialization:: *)
LogNormalHestonFondamentalTransform[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Omega]_,\[Tau]_]:=
Module[{\[Zeta]1,\[Psi]p1 ,\[Psi]m1,arg\[Zeta]1,\[Eta]1,\[Zeta]2,\[Psi]p2 ,\[Psi]m2,arg\[Zeta]2,\[Eta]2,\[Zeta]3,\[Psi]p3 ,\[Psi]m3,A3,arg\[Zeta]3,\[Eta]3,B1,B2,B3,A},
\[Eta]1=\[Lambda]v1+\[Rho]1 \[Kappa]1 I \[Omega];
arg\[Zeta]1=(\[Lambda]v1+\[Rho]1 \[Kappa]1 I \[Omega])^2+\[Kappa]1^2 (\[Omega]^2-I \[Omega]);
\[Zeta]1=Sqrt[arg\[Zeta]1];
\[Psi]p1 =-\[Eta]1+\[Zeta]1;
\[Psi]m1 =\[Eta]1+\[Zeta]1;
B1=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]1  \[Tau])))/(\[Psi]m1+\[Psi]p1 E^(-\[Zeta]1  \[Tau]));
\[Eta]2=\[Lambda]v2+\[Rho]2 \[Kappa]2 I \[Omega];
arg\[Zeta]2=\[Eta]2^2+\[Kappa]2^2 (\[Omega]^2-I \[Omega]);
\[Zeta]2=Sqrt[arg\[Zeta]2];
\[Psi]p2 =-\[Eta]2+\[Zeta]2;
\[Psi]m2 =\[Eta]2+\[Zeta]2;
B2=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]2  \[Tau])))/(\[Psi]m2+\[Psi]p2 E^(-\[Zeta]2  \[Tau]));
\[Eta]3=\[Lambda]v3+\[Rho]3 \[Kappa]3 I \[Omega];
arg\[Zeta]3=\[Eta]3^2+\[Kappa]3^2 (\[Omega]^2-I \[Omega]);
\[Zeta]3=Sqrt[arg\[Zeta]3];
\[Psi]p3 =-\[Eta]3+\[Zeta]3;
\[Psi]m3 =\[Eta]3+\[Zeta]3;
B3=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]3  \[Tau])))/(\[Psi]m3+\[Psi]p3 E^(-\[Zeta]3  \[Tau]));
A=-(( \[Theta]v1 \[Lambda]v1 (\[Tau] \[Psi]p1+2 Log[(\[Psi]m1+E^(-\[Zeta]1 \[Tau]) \[Psi]p1)/(2\[Zeta]1)]))/ (\[Kappa]1^2)   )-( \[Theta]v2 \[Lambda]v2 (\[Tau] \[Psi]p2+2 Log[(\[Psi]m2+E^(-\[Zeta]2 \[Tau]) \[Psi]p2)/(2\[Zeta]2)]))/ (\[Kappa]2^2)   -( \[Theta]v3 \[Lambda]v3 (\[Tau] \[Psi]p3+2 Log[(\[Psi]m3+E^(-\[Zeta]3 \[Tau]) \[Psi]p3)/(2\[Zeta]3)]))/ (\[Kappa]3^2)   ;
If[Re[A+B1 V1+B2 V2+B3 V3]<-100,0,
E^(A+B1 V1+B2 V2+B3 V3)]
]


(* ::Input::Initialization:: *)
LogNormalHestonFondamentalTransform[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,\[Omega]_,\[Tau]_]:=
Module[{\[Zeta]1,\[Psi]p1 ,\[Psi]m1,arg\[Zeta]1,\[Eta]1,\[Zeta]2,\[Psi]p2 ,\[Psi]m2,arg\[Zeta]2,\[Eta]2,\[Zeta]3,\[Psi]p3 ,\[Psi]m3,A3,arg\[Zeta]3,\[Eta]3,\[Zeta]4,\[Psi]p4 ,\[Psi]m4,A4,arg\[Zeta]4,\[Eta]4,B1,B2,B3,B4,A},
\[Eta]1=\[Lambda]v1+\[Rho]1 \[Kappa]1 I \[Omega];
arg\[Zeta]1=(\[Lambda]v1+\[Rho]1 \[Kappa]1 I \[Omega])^2+\[Kappa]1^2 (\[Omega]^2-I \[Omega]);
\[Zeta]1=Sqrt[arg\[Zeta]1];
\[Psi]p1 =-\[Eta]1+\[Zeta]1;
\[Psi]m1 =\[Eta]1+\[Zeta]1;
B1=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]1  \[Tau])))/(\[Psi]m1+\[Psi]p1 E^(-\[Zeta]1  \[Tau]));
\[Eta]2=\[Lambda]v2+\[Rho]2 \[Kappa]2 I \[Omega];
arg\[Zeta]2=\[Eta]2^2+\[Kappa]2^2 (\[Omega]^2-I \[Omega]);
\[Zeta]2=Sqrt[arg\[Zeta]2];
\[Psi]p2 =-\[Eta]2+\[Zeta]2;
\[Psi]m2 =\[Eta]2+\[Zeta]2;
B2=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]2  \[Tau])))/(\[Psi]m2+\[Psi]p2 E^(-\[Zeta]2  \[Tau]));
\[Eta]3=\[Lambda]v3+\[Rho]3 \[Kappa]3 I \[Omega];
arg\[Zeta]3=\[Eta]3^2+\[Kappa]3^2 (\[Omega]^2-I \[Omega]);
\[Zeta]3=Sqrt[arg\[Zeta]3];
\[Psi]p3 =-\[Eta]3+\[Zeta]3;
\[Psi]m3 =\[Eta]3+\[Zeta]3;
B3=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]3  \[Tau])))/(\[Psi]m3+\[Psi]p3 E^(-\[Zeta]3  \[Tau]));
\[Eta]4=\[Lambda]v4+\[Rho]4 \[Kappa]4 I \[Omega];
arg\[Zeta]4=\[Eta]4^2+\[Kappa]4^2 (\[Omega]^2-I \[Omega]);
\[Zeta]4=Sqrt[arg\[Zeta]4];
\[Psi]p4 =-\[Eta]4+\[Zeta]4;
\[Psi]m4 =\[Eta]4+\[Zeta]4;
B4=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]4  \[Tau])))/(\[Psi]m4+\[Psi]p4 E^(-\[Zeta]4  \[Tau]));
A=-(( \[Theta]v1 \[Lambda]v1 (\[Tau] \[Psi]p1+2 Log[(\[Psi]m1+E^(-\[Zeta]1 \[Tau]) \[Psi]p1)/(2\[Zeta]1)]))/ (\[Kappa]1^2)   )-( \[Theta]v2 \[Lambda]v2 (\[Tau] \[Psi]p2+2 Log[(\[Psi]m2+E^(-\[Zeta]2 \[Tau]) \[Psi]p2)/(2\[Zeta]2)]))/ (\[Kappa]2^2)   -( \[Theta]v3 \[Lambda]v3 (\[Tau] \[Psi]p3+2 Log[(\[Psi]m3+E^(-\[Zeta]3 \[Tau]) \[Psi]p3)/(2\[Zeta]3)]))/ (\[Kappa]3^2)   -( \[Theta]v4 \[Lambda]v4 (\[Tau] \[Psi]p4+2 Log[(\[Psi]m4+E^(-\[Zeta]4 \[Tau]) \[Psi]p4)/(2\[Zeta]4)]))/ (\[Kappa]4^2)   ;
If[Re[A+B1 V1+B2 V2+B3 V3+B4 V4]<-100,0,
E^(A+B1 V1+B2 V2+B3 V3+B4 V4)]
]


(* ::Input::Initialization:: *)
LogNormalHestonFondamentalTransform[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,\[Rho]5_,\[Lambda]v5_,\[Theta]v5_,\[Kappa]5_,V5_,\[Omega]_,\[Tau]_]:=
Module[{\[Zeta]1,\[Psi]p1 ,\[Psi]m1,arg\[Zeta]1,\[Eta]1,\[Zeta]2,\[Psi]p2 ,\[Psi]m2,arg\[Zeta]2,\[Eta]2,\[Zeta]3,\[Psi]p3 ,\[Psi]m3,A3,arg\[Zeta]3,\[Eta]3,\[Zeta]4,\[Psi]p4 ,\[Psi]m4,A4,arg\[Zeta]4,\[Eta]4,\[Zeta]5,\[Psi]p5 ,\[Psi]m5,A5,arg\[Zeta]5,\[Eta]5,B1,B2,B3,B4,B5,A},
\[Eta]1=\[Lambda]v1+\[Rho]1 \[Kappa]1 I \[Omega];
arg\[Zeta]1=(\[Lambda]v1+\[Rho]1 \[Kappa]1 I \[Omega])^2+\[Kappa]1^2 (\[Omega]^2-I \[Omega]);
\[Zeta]1=Sqrt[arg\[Zeta]1];
\[Psi]p1 =-\[Eta]1+\[Zeta]1;
\[Psi]m1 =\[Eta]1+\[Zeta]1;
B1=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]1  \[Tau])))/(\[Psi]m1+\[Psi]p1 E^(-\[Zeta]1  \[Tau]));
\[Eta]2=\[Lambda]v2+\[Rho]2 \[Kappa]2 I \[Omega];
arg\[Zeta]2=\[Eta]2^2+\[Kappa]2^2 (\[Omega]^2-I \[Omega]);
\[Zeta]2=Sqrt[arg\[Zeta]2];
\[Psi]p2 =-\[Eta]2+\[Zeta]2;
\[Psi]m2 =\[Eta]2+\[Zeta]2;
B2=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]2  \[Tau])))/(\[Psi]m2+\[Psi]p2 E^(-\[Zeta]2  \[Tau]));
\[Eta]3=\[Lambda]v3+\[Rho]3 \[Kappa]3 I \[Omega];
arg\[Zeta]3=\[Eta]3^2+\[Kappa]3^2 (\[Omega]^2-I \[Omega]);
\[Zeta]3=Sqrt[arg\[Zeta]3];
\[Psi]p3 =-\[Eta]3+\[Zeta]3;
\[Psi]m3 =\[Eta]3+\[Zeta]3;
B3=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]3  \[Tau])))/(\[Psi]m3+\[Psi]p3 E^(-\[Zeta]3  \[Tau]));
\[Eta]4=\[Lambda]v4+\[Rho]4 \[Kappa]4 I \[Omega];
arg\[Zeta]4=\[Eta]4^2+\[Kappa]4^2 (\[Omega]^2-I \[Omega]);
\[Zeta]4=Sqrt[arg\[Zeta]4];
\[Psi]p4 =-\[Eta]4+\[Zeta]4;
\[Psi]m4 =\[Eta]4+\[Zeta]4;
B4=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]4  \[Tau])))/(\[Psi]m4+\[Psi]p4 E^(-\[Zeta]4  \[Tau]));
\[Eta]5=\[Lambda]v5+\[Rho]5 \[Kappa]5 I \[Omega];
arg\[Zeta]5=\[Eta]5^2+\[Kappa]5^2 (\[Omega]^2-I \[Omega]);
\[Zeta]5=Sqrt[arg\[Zeta]5];
\[Psi]p5 =-\[Eta]5+\[Zeta]5;
\[Psi]m5 =\[Eta]5+\[Zeta]5;
B5=( -(\[Omega]^2-I \[Omega])(1-E^(-\[Zeta]5  \[Tau])))/(\[Psi]m5+\[Psi]p5 E^(-\[Zeta]5  \[Tau]));
A=-(( \[Theta]v1 \[Lambda]v1 (\[Tau] \[Psi]p1+2 Log[(\[Psi]m1+E^(-\[Zeta]1 \[Tau]) \[Psi]p1)/(2\[Zeta]1)]))/ (\[Kappa]1^2)   )-( \[Theta]v2 \[Lambda]v2 (\[Tau] \[Psi]p2+2 Log[(\[Psi]m2+E^(-\[Zeta]2 \[Tau]) \[Psi]p2)/(2\[Zeta]2)]))/ (\[Kappa]2^2)   -( \[Theta]v3 \[Lambda]v3 (\[Tau] \[Psi]p3+2 Log[(\[Psi]m3+E^(-\[Zeta]3 \[Tau]) \[Psi]p3)/(2\[Zeta]3)]))/ (\[Kappa]3^2)   -( \[Theta]v4 \[Lambda]v4 (\[Tau] \[Psi]p4+2 Log[(\[Psi]m4+E^(-\[Zeta]4 \[Tau]) \[Psi]p4)/(2\[Zeta]4)]))/ (\[Kappa]4^2)   -( \[Theta]v5 \[Lambda]v5 (\[Tau] \[Psi]p5+2 Log[(\[Psi]m5+E^(-\[Zeta]5 \[Tau]) \[Psi]p5)/(2\[Zeta]5)]))/ (\[Kappa]5^2)   ;
If[Re[A+B1 V1+B2 V2+B3 V3+B4 V4+B5 V5]<-100,0,
E^(A+B1 V1+B2 V2+B3 V3+B4 V4+B5 V5)]
]


(* ::Input::Initialization:: *)
LogNormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,S0_,K_,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0]) LogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Omega],T]LogNormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]]]


(* ::Input::Initialization:: *)
LogNormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,K_,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0])  LogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Omega],T]LogNormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]]]


(* ::Input::Initialization:: *)
LogNormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,K_,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0])  LogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Omega],T]LogNormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]]]


(* ::Input::Initialization:: *)
LogNormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,S0_,K_,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0])  LogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,\[Omega],T]LogNormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]]]


(* ::Input::Initialization:: *)
LogNormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,\[Rho]5_,\[Lambda]v5_,\[Theta]v5_,\[Kappa]5_,V5_,S0_,K_,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0])  LogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,\[Rho]5,\[Lambda]v5,\[Theta]v5,\[Kappa]5,V5,\[Omega],T]LogNormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]]]


(* ::Input::Initialization:: *)
LogNormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,S0_,K_List,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0])  LogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Omega],T]Table[LogNormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]],{i,1,Length[K]}]]


(* ::Input::Initialization:: *)
LogNormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,K_List,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0])  LogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Omega],T]Table[LogNormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]],{i,1,Length[K]}]]


(* ::Input::Initialization:: *)
LogNormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,K_List,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0])  LogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Omega],T]Table[LogNormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]],{i,1,Length[K]}]]


(* ::Input::Initialization:: *)
LogNormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,S0_,K_List,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0])  LogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,\[Omega],T]LogNormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]]]


(* ::Input::Initialization:: *)
LogNormalHestonCallIntegrand[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,\[Rho]5_,\[Lambda]v5_,\[Theta]v5_,\[Kappa]5_,V5_,S0_,K_List,\[Alpha]_,a_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0])  LogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,\[Rho]5,\[Lambda]v5,\[Theta]v5,\[Kappa]5,V5,\[Omega],T]LogNormalCallPayOffFourierTransform[K,\[Alpha],a,\[Omega]]]


(* ::Input::Initialization:: *)
LogHestonNormalCallN[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=S0-1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
NIntegrate[LogNormalHestonCallIntegrand[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,1,1,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
LogHestonNormalCallN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,T_]:=S0-1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
NIntegrate[LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,k,1,1,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
LogHestonNormalCallN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,T_]:=S0-1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
NIntegrate[LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,k,1,1,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
LogHestonNormalCallN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,S0_,k_,T_]:=S0-1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
NIntegrate[LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,S0,k,1,1,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
LogHestonNormalCallN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,\[Rho]5_,\[Lambda]v5_,\[Theta]v5_,\[Kappa]5_,V5_,S0_,k_,T_]:=S0-1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
NIntegrate[LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,\[Rho]5,\[Lambda]v5,\[Theta]v5,\[Kappa]5,V5,S0,k,1,1,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
LogHestonNormalCallAux[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=S0-1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,1,1,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,2,10^(-10),1000,2,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
LogHestonNormalCallAux[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,T_]:=S0-1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,k,1,1,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
LogHestonNormalCallAux[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,T_]:=S0-1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,k,1,1,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
LogHestonNormalCallAux[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,S0_,k_,T_]:=S0-1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,S0,k,1,1,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
LogHestonNormalCallAux[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,\[Rho]5_,\[Lambda]v5_,\[Theta]v5_,\[Kappa]5_,V5_,S0_,k_,T_]:=S0-1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,\[Rho]5,\[Lambda]v5,\[Theta]v5,\[Kappa]5,V5,S0,k,1,1,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
LogHestonNormalCall[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=Module[{},
S0 LogHestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,1,k/S0,T]
]


(* ::Input::Initialization:: *)
LogHestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,T_]:=Module[{},
S0 LogHestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,1,k/S0,T]
]


(* ::Input::Initialization:: *)
LogHestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,T_]:=Module[{},
S0 LogHestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,1,k/S0,T]
]


(* ::Input::Initialization:: *)
LogHestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,S0_,k_,T_]:=Module[{},
S0 LogHestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,1,k/S0,T]
]


(* ::Input::Initialization:: *)
LogHestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,\[Rho]5_,\[Lambda]v5_,\[Theta]v5_,\[Kappa]5_,V5_,S0_,k_,T_]:=Module[{},
S0 LogHestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,\[Rho]5,\[Lambda]v5,\[Theta]v5,\[Kappa]5,V5,1,k/S0,T]
]


(* ::Input::Initialization:: *)
LogHestonNormalDensit\[EAcute][\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=Module[{shift=S0/1000},Max[0,(LogHestonNormalCall[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k+shift,T]+LogHestonNormalCall[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k-shift,T]-2LogHestonNormalCall[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,T])/(shift^2)]]


(* ::Input::Initialization:: *)
LogHestonNormalDensit\[EAcute][\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,T_]:=Module[{shift=S0/1000},Max[0,(LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,k+shift,T]+LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,k-shift,T]-2LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,k,T])/(shift^2)]]


(* ::Input::Initialization:: *)
LogHestonNormalDensit\[EAcute][\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,T_]:=Module[{shift=S0/1000},Max[0,(LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,k+shift,T]+LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,k-shift,T]-2LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,k,T])/(shift^2)]]


(* ::Input::Initialization:: *)
LogHestonNormalDensit\[EAcute][\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,S0_,k_,T_]:=Module[{shift=S0/1000},Max[0,(LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,S0,k+shift,T]+LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,S0,k-shift,T]-2LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,S0,k,T])/(shift^2)]]


(* ::Input::Initialization:: *)
LogHestonNormalDensit\[EAcute][\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,\[Rho]5_,\[Lambda]v5_,\[Theta]v5_,\[Kappa]5_,V5_,S0_,k_,T_]:=Module[{shift=S0/1000},Max[0,(LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,\[Rho]5,\[Lambda]v5,\[Theta]v5,\[Kappa]5,V5,S0,k+shift,T]+LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,\[Rho]5,\[Lambda]v5,\[Theta]v5,\[Kappa]5,V5,S0,k-shift,T]-2LogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Rho]4,\[Lambda]v4,\[Theta]v4,\[Kappa]4,V4,\[Rho]5,\[Lambda]v5,\[Theta]v5,\[Kappa]5,V5,S0,k,T])/(shift^2)]]


(* ::Input::Initialization:: *)
CoeffBasedVariance[density_,coeffs_]:=Module[{n=Length[coeffs],densitytable,Expectation=0,variance=0,normalisation=0,i},
densitytable=Table[density[coeffs[[i,1]]],{i,1,n}];
Do[normalisation+= densitytable[[i]] coeffs[[i,2]],{i,1,n}];
Do[Expectation+=coeffs[[i,1]] densitytable[[i]] coeffs[[i,2]],{i,1,n}];Expectation/=normalisation;
Do[variance+=(coeffs[[i,1]]-Expectation)^2 densitytable[[i]] coeffs[[i,2]],{i,1,n}];
Print["normalisation=",normalisation," Expectation=",Expectation," variance=",variance];
variance/=normalisation;
variance]


(* ::Input::Initialization:: *)
CoeffBasedVariance[density_,coeffs_,Expectation_]:=Module[{n=Length[coeffs],densitytable,variance=0,i},
densitytable=Table[density[coeffs[[i,1]]],{i,1,n}];
Do[variance+=(coeffs[[i,1]]-Expectation)^2 densitytable[[i]] coeffs[[i,2]],{i,1,n}];
variance]


(* ::Input::Initialization:: *)
LogHestonNormalVariance2[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=CoeffBasedIntegrate[((#-S0)^2 LogHestonNormalDensit\[EAcute][\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,#,T])&,LegendreCoeffs[20,S0/5,6S0]]


(* ::Input::Initialization:: *)
LogHestonNormalVariance3[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=CoeffBasedVariance[(LogHestonNormalDensit\[EAcute][\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,#,T])&,LegendreCoeffs[20,S0/5,6S0]]


(* ::Input::Initialization:: *)
LogHestonNormalEsperance[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=CoeffBasedIntegrate[((#)LogHestonNormalDensit\[EAcute][\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,#,T])&,LegendreCoeffs[20,S0/5,6S0]]


(* ::Input::Initialization:: *)
LogHestonNormalNormalisation[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=CoeffBasedIntegrate[(LogHestonNormalDensit\[EAcute][\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,#,T])&,LegendreCoeffs[20,S0/5,6S0]]


(* ::Input::Initialization:: *)
LogHestonNormalVarianceProxy[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,T_]:=Module[{Vlog},
Vlog=\[Theta]v T+(V -\[Theta]v)((1-E^(-\[Lambda]v T))/\[Lambda]v);
S0^2 E^Vlog (E^Vlog-1)]


(* ::Input::Initialization:: *)
LogHestonNormalVarianceProxy[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,T_]:=Module[{Vlog1,Vlog2},
Vlog1=\[Theta]v1 T+(V1 -\[Theta]v1)((1-E^(-\[Lambda]v1 T))/\[Lambda]v1);
Vlog2=\[Theta]v2 T+(V2 -\[Theta]v2)((1-E^(-\[Lambda]v2 T))/\[Lambda]v2);
S0^2 E^(Vlog1+Vlog2) (E^(Vlog1+Vlog2)-1)
]  


(* ::Input::Initialization:: *)
LogHestonNormalVarianceProxy[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,T_]:=Module[{Vlog1,Vlog2,Vlog3},
Vlog1=\[Theta]v1 T+(V1 -\[Theta]v1)((1-E^(-\[Lambda]v1 T))/\[Lambda]v1);
Vlog2=\[Theta]v2 T+(V2 -\[Theta]v2)((1-E^(-\[Lambda]v2 T))/\[Lambda]v2);
Vlog3=\[Theta]v3 T+(V3 -\[Theta]v3)((1-E^(-\[Lambda]v3 T))/\[Lambda]v3);
S0^2 E^(Vlog1+Vlog2+Vlog3) (E^(Vlog1+Vlog2+Vlog3)-1)
]  


(* ::Input::Initialization:: *)
LogHestonNormalVarianceProxy[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,S0_,T_]:=Module[{Vlog1,Vlog2,Vlog3,Vlog4},
Vlog1=\[Theta]v1 T+(V1 -\[Theta]v1)((1-E^(-\[Lambda]v1 T))/\[Lambda]v1);
Vlog2=\[Theta]v2 T+(V2 -\[Theta]v2)((1-E^(-\[Lambda]v2 T))/\[Lambda]v2);
Vlog3=\[Theta]v3 T+(V3 -\[Theta]v3)((1-E^(-\[Lambda]v3 T))/\[Lambda]v3);
Vlog4=\[Theta]v4 T+(V4 -\[Theta]v4)((1-E^(-\[Lambda]v4 T))/\[Lambda]v4);
S0^2 E^(Vlog1+Vlog2+Vlog3+Vlog4) (E^(Vlog1+Vlog2+Vlog3+Vlog4)-1)
]  


(* ::Input::Initialization:: *)
LogHestonNormalVarianceProxy[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Rho]4_,\[Lambda]v4_,\[Theta]v4_,\[Kappa]4_,V4_,\[Rho]5_,\[Lambda]v5_,\[Theta]v5_,\[Kappa]5_,V5_,S0_,T_]:=Module[{Vlog1,Vlog2,Vlog3,Vlog4,Vlog5},
Vlog1=\[Theta]v1 T+(V1 -\[Theta]v1)((1-E^(-\[Lambda]v1 T))/\[Lambda]v1);
Vlog2=\[Theta]v2 T+(V2 -\[Theta]v2)((1-E^(-\[Lambda]v2 T))/\[Lambda]v2);
Vlog3=\[Theta]v3 T+(V3 -\[Theta]v3)((1-E^(-\[Lambda]v3 T))/\[Lambda]v3);
Vlog4=\[Theta]v4 T+(V4 -\[Theta]v4)((1-E^(-\[Lambda]v4 T))/\[Lambda]v4);
Vlog5=\[Theta]v5 T+(V5 -\[Theta]v5)((1-E^(-\[Lambda]v5 T))/\[Lambda]v5);
S0^2 E^(Vlog1+Vlog2+Vlog3+Vlog4+Vlog5) (E^(Vlog1+Vlog2+Vlog3+Vlog4+Vlog5)-1)
]  


(* ::Input::Initialization:: *)
LogHestonNormalVariance2[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_,n1_,n2_]:=CoeffBasedVariance[(LogHestonNormalDensit\[EAcute][\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,#,T])&,LegendreCoeffs[60,S0/n1,n2 S0]]


(* ::Input::Initialization:: *)
LogHestonNormalCallAux[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=S0-1/\[Pi] Re[Module[{\[Lambda]=0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,1,1,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[12],
10,2,10^(-10),1000,2,LegendreCoeffs[30]][[2]]]]


(* ::Input::Initialization:: *)
ShiftedLogHestonNormalCallAux[\[Beta]_,\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=Module[{},
LogHestonNormalCall[\[Rho],\[Lambda]v,\[Beta]^2 \[Theta]v,Abs[\[Beta]] \[Kappa],\[Beta]^2 V,S0+(1-\[Beta] )/\[Beta] S0,k+(1-\[Beta] )/\[Beta] S0,T]] /; \[Beta]>=0


(* ::Input::Initialization:: *)
ShiftedLogHestonNormalCallAux[\[Beta]_,\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=Module[{},
LogHestonNormalCall[-\[Rho],\[Lambda]v,\[Beta]^2 \[Theta]v,Abs[\[Beta]] \[Kappa],\[Beta]^2 V,-S0-(1-\[Beta] )/\[Beta] S0,-k-(1-\[Beta] )/\[Beta] S0,T]] /; \[Beta]<0


(* ::Input::Initialization:: *)
ShiftedLogHestonNormalCall1[\[Beta]_,\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=Module[{\[Beta]L=0.02},
If[(\[Beta]<\[Beta]L)&& (\[Beta]>=0),
(\[Beta]L-\[Beta])/\[Beta]L HestonNormalCall[\[Rho],\[Lambda]v,S0^2 \[Theta]v,S0 \[Kappa],S0^2 V,S0,k,T]+\[Beta]/\[Beta]L ShiftedLogHestonNormalCallAux[\[Beta]L,\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,T],
If[(\[Beta]>-\[Beta]L)&& (\[Beta]<0),
(\[Beta]L-Abs[\[Beta]])/\[Beta]L HestonNormalCall[\[Rho],\[Lambda]v,S0^2 \[Theta]v,S0 \[Kappa],S0^2 V,S0,k,T]+Abs[\[Beta]]/\[Beta]L ShiftedLogHestonNormalCallAux[-\[Beta]L,\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,T],
ShiftedLogHestonNormalCallAux[\[Beta],\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,T]]]]


(* ::Input::Initialization:: *)
BetaPositifApprox[\[Beta]ini_,\[Beta]L_,force_]:=\[Beta]L E^(-force \[Beta]ini)+(1-\[Beta]L E^-force) \[Beta]ini


(* ::Input::Initialization:: *)
BetaNegatifApprox[\[Beta]ini_,\[Beta]L_,force_]:=-\[Beta]L E^(force \[Beta]ini)+(1-\[Beta]L E^-force) \[Beta]ini


(* ::Input::Initialization:: *)
InterpolDenfer[x_,m_,q_]:=Module[{y,z},
y=2 (1.0-x)^q-1;
z= ArcTanh[y];
1-(Tanh[m z]+1)/2]


(* ::Input::Initialization:: *)
ShiftedLogHestonNormalCallAux[\[Beta]_,\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=Module[{},
LogHestonNormalCall[\[Rho],\[Lambda]v,\[Beta]^2 \[Theta]v,Abs[\[Beta]] \[Kappa],\[Beta]^2 V,S0+(1-\[Beta] )/\[Beta] S0,k+(1-\[Beta] )/\[Beta] S0,T]] /; \[Beta]>=0


(* ::Input::Initialization:: *)
ShiftedLogHestonNormalCallAux[\[Beta]_,\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=Module[{},
LogHestonNormalCall[-\[Rho],\[Lambda]v,\[Beta]^2 \[Theta]v,Abs[\[Beta]] \[Kappa],\[Beta]^2 V,S0-(1-\[Beta] )/\[Beta] S0,k-(1-\[Beta] )/\[Beta] S0,T]] /; \[Beta]<0


(* ::Input::Initialization:: *)
ShiftedLogHestonNormalCall2[\[Beta]_,\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,T_]:=Module[{\[Beta]L=0.02,\[Beta]eff,\[Alpha]N,\[Alpha]LN,force=1,m=2,q=3},
If[ (\[Beta]>=0),\[Alpha]LN=InterpolDenfer[\[Beta],m,q];\[Alpha]N=1-\[Alpha]LN;
\[Beta]eff=BetaPositifApprox[\[Beta],\[Beta]L,force];
(*Print["\[Beta]>0 : \[Alpha]LN=",\[Alpha]LN," \[Beta]eff=",\[Beta]eff," HestonNormalCall[\[Rho],\[Lambda]v,S0^2\[Theta]v,S0 \[Kappa],S0^2V,S0,k,T]=", HestonNormalCall[\[Rho],\[Lambda]v,S0^2\[Theta]v,S0 \[Kappa],S0^2V,S0,k,T],"  ShiftedLogHestonNormalCallAux[\[Beta]eff,\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,T]=", ShiftedLogHestonNormalCallAux[\[Beta]eff,\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,T]];*);
\[Alpha]N HestonNormalCall[\[Rho],\[Lambda]v,S0^2 \[Theta]v,S0 \[Kappa],S0^2 V,S0,k,T]+\[Alpha]LN ShiftedLogHestonNormalCallAux[\[Beta]eff,\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,T],
If[ (\[Beta]<0),\[Alpha]LN=InterpolDenfer[-\[Beta],m,q];\[Alpha]N=1-\[Alpha]LN;
\[Beta]eff=BetaNegatifApprox[\[Beta],\[Beta]L,force];
(* Print["\[Beta]<0 : \[Alpha]LN=",\[Alpha]LN," \[Beta]eff=",\[Beta]eff];*)
\[Alpha]N HestonNormalCall[\[Rho],\[Lambda]v,S0^2 \[Theta]v,S0 \[Kappa],S0^2 V,S0,k,T]+\[Alpha]LN ShiftedLogHestonNormalCallAux[\[Beta]eff,\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,T],
ShiftedLogHestonNormalCallAux[\[Beta],\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,T]]]]


(* ::Input::Initialization:: *)
phi[x_]:=Exp[-x^2/2]/Sqrt[2Pi]


(* ::Input::Initialization:: *)
Nd[x_]:=(Erf[x/Sqrt[2]]+1)/2


(* ::Input::Initialization:: *)
LogNormalSpreadDigitaleCall[S1_,S2_,sig1_,sig2_,rho_,k_,t_]:=NIntegrate[phi[x]Nd[-(Log[(k+S2 E^(-1/2 sig2^2 t+sig2 Sqrt[t] x))/(S1 E^(-1/2 sig1^2 t))]-rho sig1 Sqrt[t] x)/(Sqrt[1-rho^2] sig1 Sqrt[t])],{x,-\[Infinity],-1,+\[Infinity]}]


(* ::Input::Initialization:: *)
LogNormalSpreadDigitaleCallN[S1_,S2_,sig1_,sig2_,rho_,k_,t_]:=CoeffBasedIntegrate[(Nd[-(Log[(k+S2 E^(-1/2 sig2^2 t+sig2 Sqrt[t] #))/(S1 E^(-1/2 sig1^2 t))]-rho sig1 Sqrt[t] #)/(Sqrt[1-rho^2] sig1 Sqrt[t])])&,ModifiedHermiteCoeffs[20]]


(* ::Input::Initialization:: *)
LogNormalSpreadDigitaleCallN[S1_,S2_,sig1_,sig2_,rho_,k_,t_,nbsteps_]:=CoeffBasedIntegrate[(Nd[-(Log[(k+S2 E^(-1/2 sig2^2 t+sig2 Sqrt[t] #))/(S1 E^(-1/2 sig1^2 t))]-rho sig1 Sqrt[t] #)/(Sqrt[1-rho^2] sig1 Sqrt[t])])&,ModifiedHermiteCoeffs[nbsteps]]


(* ::Input::Initialization:: *)
LogNormalSpreadDigitaleCall[S1_,S2_,sig1_,sig2_,rho_,k_,t_]:=If[k>=0,LogNormalSpreadDigitaleCallN[S1 ,S2 ,sig1,sig2,rho,k,t],1-LogNormalSpreadDigitaleCallN[S2 ,S1 ,sig2,sig1,rho,-k,t]]


(* ::Input::Initialization:: *)
MesureQTLogNormalSpreadDigitale[S1_,S2_,sig1_,sig2_,rho_,k_,t_]:=LogNormalSpreadDigitaleCall[S1 ,S2 ,sig1,sig2,rho,k,t]


(* ::Input::Initialization:: *)
MesureQ1LogNormalSpreadDigitale[S1_,S2_,sig1_,sig2_,rho_,k_,t_]:=LogNormalSpreadDigitaleCall[S1 Exp[sig1^2 t],S2 Exp[rho sig1 sig2 t],sig1,sig2,rho,k,t]


(* ::Input::Initialization:: *)
MesureQ2LogNormalSpreadDigitale[S1_,S2_,sig1_,sig2_,rho_,k_,t_]:=LogNormalSpreadDigitaleCall[S1 Exp[rho sig1 sig2 t],S2 Exp[sig2^2 t],sig1,sig2,rho,k,t]


(* ::Input::Initialization:: *)
LogNormalSpreadDigitaleCall[S1_,S2_,sig1_,sig2_,rho_,k_,t_,nb_]:=If[k>=0,LogNormalSpreadDigitaleCallN[S1 ,S2 ,sig1,sig2,rho,k,t,nb],1-LogNormalSpreadDigitaleCallN[S2 ,S1 ,sig2,sig1,rho,-k,t,nb]]


(* ::Input::Initialization:: *)
MesureQTLogNormalSpreadDigitale[S1_,S2_,sig1_,sig2_,rho_,k_,t_,nb_]:=LogNormalSpreadDigitaleCall[S1 ,S2 ,sig1,sig2,rho,k,t,nb]


(* ::Input::Initialization:: *)
MesureQ1LogNormalSpreadDigitale[S1_,S2_,sig1_,sig2_,rho_,k_,t_,nb_]:=LogNormalSpreadDigitaleCall[S1 Exp[sig1^2 t],S2 Exp[rho sig1 sig2 t],sig1,sig2,rho,k,t,nb]


(* ::Input::Initialization:: *)
MesureQ2LogNormalSpreadDigitale[S1_,S2_,sig1_,sig2_,rho_,k_,t_,nb_]:=LogNormalSpreadDigitaleCall[S1 Exp[rho sig1 sig2 t],S2 Exp[sig2^2 t],sig1,sig2,rho,k,t,nb]


(* ::Input::Initialization:: *)
MesureQ2LogNormalSpreadDigitaleZ[S1_,S2_,sig1_,sig2_,rho_,k_,t_]:=1-MesureQ1LogNormalSpreadDigitale[S2,S1,sig2,sig1,rho,-k,t]


(* ::Input::Initialization:: *)
LogNormalSpreadOption[S1_,S2_,sig1_,sig2_,rho_,k_,t_]:=S1 MesureQ1LogNormalSpreadDigitale[S1,S2,sig1,sig2,rho,k,t]-S2 MesureQ2LogNormalSpreadDigitale[S1,S2,sig1,sig2,rho,k,t]-k MesureQTLogNormalSpreadDigitale[S1,S2,sig1,sig2,rho,k,t]


(* ::Input::Initialization:: *)
LogNormalSpreadOption[S1_,S2_,sig1_,sig2_,rho_,k_,t_,nb_]:=S1 MesureQ1LogNormalSpreadDigitale[S1,S2,sig1,sig2,rho,k,t,nb]-S2 MesureQ2LogNormalSpreadDigitale[S1,S2,sig1,sig2,rho,k,t,nb]-k MesureQTLogNormalSpreadDigitale[S1,S2,sig1,sig2,rho,k,t,nb]


(* ::Input::Initialization:: *)
LogNormalSpreadDensity[S1_,S2_,sig1_,sig2_,rho_,k_,t_]:=CoeffBasedIntegrate[(E^(1/2 (-#^2+(-rho sig1 Sqrt[t] #+Log[(E^((sig1^2 t)/2) (k+E^(-((sig2^2 t)/2)+sig2 Sqrt[t]#) S2))/S1])^2/((-1+rho^2) sig1^2 t)))/(2 \[Pi] Sqrt[1-rho^2] (k+E^(-((sig2^2 t)/2)+sig2 Sqrt[t] #) S2) sig1 Sqrt[t]))&,ModifiedHermiteCoeffs[20]]


(* ::Input::Initialization:: *)
ModeMoins3NuMinimunNormalHestonFromBilogProxy[S1_,S2_,\[Sigma]1_,\[Sigma]2_,Correl12_,T_]:=
Module[{varvar,VS},
VS=(\[Sigma]1^2 S1^2+\[Sigma]2^2 S2^2-2Correl12 \[Sigma]1 \[Sigma]2 S1 S2);
varvar=4 \[Sigma]1^4 (S1 \[Sigma]1-Correl12 S2 \[Sigma]2)^2+4 \[Sigma]2^4 (Correl12 S1 \[Sigma]1-S2 \[Sigma]2)^2+8 Correl12 \[Sigma]1^2 \[Sigma]2^2 (Correl12 S1 \[Sigma]1-S2 \[Sigma]2) (Correl12 S2 \[Sigma]2-S1 \[Sigma]1);
{VS,Sqrt[varvar]/Sqrt[VS]}]


(* ::Input::Initialization:: *)
NormalHestonSmileCalibrate[KList_,PriceList_,WeightList_,S0_,\[Lambda]_,LT_,T_,nbsteps_,scale_,microratio_]:=Module[{func,gradfunc,V0,rho,nu,ss,NewWeightList},
V0=10^(-5);
NewWeightList=Table[WeightList[[i]]/NormalCallVega[S0,KList[[i]],T,Sqrt[V0]],{i,1,Length[WeightList]}];
func=Function[{V,\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[\[Rho],\[Lambda],LT,\[Nu],V,S0,KList,T,nbsteps,scale,microratio,0]},
Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])^2,{i,1,Length[KList]}]]];
gradfunc=Function[{V,\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[\[Rho],\[Lambda],LT,\[Nu],V,S0,KList,T,nbsteps,scale,microratio]},
{Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[2,i]],{i,1,Length[KList]}],
Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[3,i]],{i,1,Length[KList]}],
Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[4,i]],{i,1,Length[KList]}]
}]];
ss=FindMinimum[func[V0,rho,nu],{{V0,0.00003,0.0000001,0.001},{nu,0.001,0.000001,0.1},{rho,0,-0.9,0.9}},
MaxIterations->200,AccuracyGoal->7,Method->"LevenbergMarquardt",
Gradient->gradfunc[V0,rho,nu]] ;
{ss[[1]],{V0,rho,nu}} /. ss[[2]]
]



(* ::Input::Initialization:: *)
NormalHestonSmileCalibrateV0Fixed[KList_,PriceList_,WeightList_,S0_,V0_,\[Lambda]_,LT_,T_,nbsteps_,scale_,microratio_]:=Module[{func,gradfunc,rho,nu,ss,NewWeightList},
NewWeightList=Table[WeightList[[i]]/NormalCallVega[S0,KList[[i]],T,Sqrt[V0]],{i,1,Length[WeightList]}];
func=Function[{\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[\[Rho],\[Lambda],LT,\[Nu],V0,S0,KList,T,nbsteps,scale,microratio,0]},
Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])^2,{i,1,Length[KList]}]]];
gradfunc=Function[{\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[\[Rho],\[Lambda],LT,\[Nu],V0,S0,KList,T,nbsteps,scale,microratio]},
{Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[3,i]],{i,1,Length[KList]}],
Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[4,i]],{i,1,Length[KList]}]
}]];
ss=FindMinimum[{func[rho,nu],(rho>-1)&&(rho<1)},{{nu,0.001,0.000001,0.01},{rho,0,-0.9,0.9}},
MaxIterations->200,AccuracyGoal->8,
Gradient->gradfunc[rho,nu]] ;
{ss[[1]],{V0,rho,nu}} /. ss[[2]]
]



(* ::Input::Initialization:: *)
NormalHestonSmileCalibrateV0Controlled[KList_,PriceList_,WeightList_,S0_,V0_,\[Lambda]_,LT_,T_,nbsteps_,scale_,microratio_]:=Module[{func,gradfunc,V,rho,nu,ss},
func=Function[{V,\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[\[Rho],\[Lambda],LT,\[Nu],V,S0,KList,T,nbsteps,scale,microratio,0]},
Sum[WeightList[[i]](PriceList[[i]]-ff[[1,i]])^2,{i,1,Length[KList]}]]];
gradfunc=Function[{V,\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[\[Rho],\[Lambda],LT,\[Nu],V,S0,KList,T,nbsteps,scale,microratio]},
{Sum[WeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[2,i]],{i,1,Length[KList]}],
Sum[WeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[3,i]],{i,1,Length[KList]}],
Sum[WeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[4,i]],{i,1,Length[KList]}]
}]];
ss=FindMinimum[{func[V,rho,nu],(rho>-1)&&(rho<1)&&(V>1.05V0)&&(V<1.5V0)&&(nu>0)},{{V,V0,0.000001,0.01},{nu,0.001,0.000001,0.01},{rho,0,-0.9,0.9}},
MaxIterations->200,AccuracyGoal->8,
Gradient->gradfunc[V,rho,nu]] ;
{ss[[1]],{V,rho,nu}} /. ss[[2]]
]



(* ::Input::Initialization:: *)
HestonFromBilog[S1_,S2_,\[Sigma]1_,\[Sigma]2_,Correl12_,T_,\[Lambda]_,LT_]:=
Module[{strikes,Stdev,pricegoaltable,WeightList,nbsteps,scale,microratio,nbstrike,ss,V0,\[Rho],\[Nu]},
Stdev=Sqrt[T] Sqrt[S1^2 \[Sigma]1^2+S2^2 \[Sigma]2^2-2Correl12 S1 S2 \[Sigma]1 \[Sigma]2];
Print["Stdev(pour le calcul des strike)=",Stdev];
strikes={- Stdev/3,-Stdev/6,0,Stdev/6,Stdev/3};
Print["strikes=",strikes];
nbstrike=Length[strikes];
pricegoaltable=Table[LogNormalSpreadOption[S1,S2,\[Sigma]1,\[Sigma]2,Correl12,strikes[[i]],T,12],{i,1,nbstrike}];
Print["pricegoaltable=",pricegoaltable];
WeightList=Table[1,{i,1,nbstrike}];nbsteps=40;scale=8;
microratio=5 T^(1/2);
ss=NormalHestonSmileCalibrate[strikes,pricegoaltable,WeightList,S1-S2,\[Lambda],LT,T,nbsteps,scale,microratio];
Print["optimisation results:",ss];
ss[[2]]
]


(* ::Input::Initialization:: *)
HestonFromBilogV0Fixed[S1_,S2_,\[Sigma]1_,\[Sigma]2_,Correl12_,T_,\[Lambda]_,LT_,Vmultiplicator_]:=
Module[{V,strikes,Stdev,pricegoaltable,WeightList,nbsteps,scale,microratio,nbstrike,ss,V0,\[Rho],\[Nu]},
V=S1^2 \[Sigma]1^2+S2^2 \[Sigma]2^2-2Correl12 S1 S2 \[Sigma]1 \[Sigma]2;
V0=Vmultiplicator V;
Stdev=Sqrt[V0 T];
Print["Stdev(pour le calcul des strike)=",Stdev];
strikes={- Stdev/3,-Stdev/6,0,Stdev/6,Stdev/3};
Print["strikes=",strikes];
nbstrike=Length[strikes];
pricegoaltable=Table[LogNormalSpreadOption[S1,S2,\[Sigma]1,\[Sigma]2,Correl12,strikes[[i]],T,12],{i,1,nbstrike}];
Print["pricegoaltable=",pricegoaltable];
WeightList=Table[1,{i,1,nbstrike}];nbsteps=40;scale=8;microratio=5 T ^(1/2);
ss=NormalHestonSmileCalibrateV0Fixed[strikes,pricegoaltable,WeightList,S1-S2,V0,\[Lambda],LT,T,nbsteps,scale,microratio];
Print["optimisation results:",ss];
ss[[2]]
]


(* ::Input::Initialization:: *)
HestonFromBilogV0Controlled[S1_,S2_,\[Sigma]1_,\[Sigma]2_,Correl12_,T_,\[Lambda]_,LT_]:=
Module[{strikes,Stdev,volgoaltable,WeightList,nbsteps,scale,microratio,nbstrike,ss,V0,\[Rho],\[Nu]},
V0=S1^2 \[Sigma]1^2+S2^2 \[Sigma]2^2-2Correl12 S1 S2 \[Sigma]1 \[Sigma]2;
Stdev=Sqrt[V0 T];Print[Stdev];
strikes={- Stdev/3,-Stdev/6,0,Stdev/6,Stdev/3};Print["strikes=",strikes];
nbstrike=Length[strikes];
volgoaltable=Table[LogNormalSpreadOption[S1,S2,\[Sigma]1,\[Sigma]2,Correl12,strikes[[i]],T,12],{i,1,nbstrike}];
WeightList=Table[1,{i,1,nbstrike}];nbsteps=40;scale=8;microratio=5 T ^(1/2);
ss=NormalHestonSmileCalibrateV0Controlled[strikes,volgoaltable,WeightList,S1-S2,V0,\[Lambda],LT,T,nbsteps,scale,microratio];
Print["optimisation results:",ss];
ss[[2]]
]


(* ::Input::Initialization:: *)
\[CapitalPhi]Controle[x_,\[Lambda]_]:=1/(2\[Lambda]) Log[Cosh[x \[Lambda]]/Cosh[\[Lambda]-x \[Lambda]]]+1/2


(* ::Input::Initialization:: *)
\[CapitalPhi]ControleInverse[y_,\[Lambda]_]:=Module[{z=E^(-\[Lambda]+2 y \[Lambda])},ArcCosh[(z Sqrt[-1+2 z Cosh[\[Lambda]]-z^2 Cosh[\[Lambda]]^2] Sinh[\[Lambda]])/((-1+z Cosh[\[Lambda]]) Sqrt[1-2 z Cosh[\[Lambda]]+z^2 Cosh[\[Lambda]]^2-z^2 Sinh[\[Lambda]]^2])]/\[Lambda]]


(* ::Input::Initialization:: *)
ControleVariable[x_,Limdown_,Limup_,\[Lambda]_]:=(Limup-Limdown)\[CapitalPhi]Controle[(x-Limdown)/(Limup-Limdown),\[Lambda]]+Limdown


(* ::Input::Initialization:: *)
DControleVariable[x_,Limdown_,Limup_,\[Lambda]_]:=1/2 (Tanh[((Limdown-x) \[Lambda])/(Limdown-Limup)]+Tanh[((-Limup+x) \[Lambda])/(Limdown-Limup)])


(* ::Input::Initialization:: *)
NormalHestonSmileCalibratePackaged[KList_,PriceList_,WeightList_,S0_,\[Lambda]_,LT_,T_,nbsteps_,scale_,microratio_,InitialV0_,StandardizedNuMax_,\[Lambda]smooth_]:=Module[{func,gradfunc,V0,rho,nu,ss,NewWeightList,\[Rho]down=-0.9,\[Rho]up=0.9,\[Nu]down=0.000001,\[Nu]up,V0down,V0up,StartingV0},
Print["args=",{KList,PriceList,WeightList,S0,\[Lambda],LT,T,nbsteps,scale,microratio,InitialV0,StandardizedNuMax,\[Lambda]smooth}];
V0down=InitialV0 0.95;V0up=10 InitialV0;\[Nu]up=StandardizedNuMax Sqrt[InitialV0];
NewWeightList=Table[WeightList[[i]]/NormalCallVega[S0,KList[[i]],T,Sqrt[InitialV0]],{i,1,Length[WeightList]}];
func=Function[{V,\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[
ControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth],\[Lambda],LT,
ControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth],
ControleVariable[V,V0down,V0up,\[Lambda]smooth],S0,KList,T,nbsteps,scale,microratio,0]},
Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])^2,{i,1,Length[KList]}]]];
gradfunc=Function[{V,\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[
ControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth],\[Lambda],LT,
ControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth],
ControleVariable[V,V0down,V0up,\[Lambda]smooth],S0,KList,T,nbsteps,scale,microratio]},
{DControleVariable[V,V0down,V0up,\[Lambda]smooth] Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[2,i]],{i,1,Length[KList]}],
DControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth]Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[3,i]],{i,1,Length[KList]}],
DControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth]Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[4,i]],{i,1,Length[KList]}]
}]];
StartingV0=InitialV0 1.05;
ss=FindMinimum[func[V0,rho,nu],{{V0,StartingV0,V0down,V0up},{nu,0.5Sqrt[InitialV0],\[Nu]down,\[Nu]up},{rho,0,\[Rho]down,\[Rho]up}},
MaxIterations->200,AccuracyGoal->7,Method->"LevenbergMarquardt",
Gradient->gradfunc[V0,rho,nu]] ;
{ss[[1]],{V0,rho,nu}} /. ss[[2]]
]


(* ::Input::Initialization:: *)
ShowProblemsNormalHestonSmileCalibratePackaged[KList_,PriceList_,WeightList_,S0_,\[Lambda]_,LT_,T_,nbsteps_,scale_,microratio_,InitialV0_,StandardizedNuMax_,\[Lambda]smooth_]:=Module[
{func,gradfunc,V0,rho,nu,ss,NewWeightList,\[Rho]down=-0.9,\[Rho]up=0.9,\[Nu]down=0.000001,\[Nu]up,V0down,V0up,StartingV0},
V0down=InitialV0 0.5;V0up=10 InitialV0;\[Nu]up=StandardizedNuMax Sqrt[InitialV0];
NewWeightList=Table[WeightList[[i]]/NormalCallVega[S0,KList[[i]],T,Sqrt[InitialV0]],{i,1,Length[WeightList]}];
func=Function[{V,\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[
ControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth],\[Lambda],LT,
ControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth],
ControleVariable[V,V0down,V0up,\[Lambda]smooth],S0,KList,T,nbsteps,scale,microratio,0]},
Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])^2,{i,1,Length[KList]}]]];
gradfunc=Function[{V,\[Rho],\[Nu]},Module[{ff=DerivativeHestonNormalCall[
ControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth],\[Lambda],LT,
ControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth],
ControleVariable[V,V0down,V0up,\[Lambda]smooth],S0,KList,T,nbsteps,scale,microratio]},
{DControleVariable[V,V0down,V0up,\[Lambda]smooth] Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[2,i]],{i,1,Length[KList]}],
DControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth]Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[3,i]],{i,1,Length[KList]}],
DControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth]Sum[NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[4,i]],{i,1,Length[KList]}]
}]];
StartingV0=InitialV0 1.05;
{Plot3D[func[V0,0,nu],{V0,V0down,V0up/4},{nu,\[Nu]down,\[Nu]up},AxesLabel->{"V0","nu"}] ,
Plot3D[func[StartingV0,rho,nu],{nu,\[Nu]down,\[Nu]up},{rho,\[Rho]down,\[Rho]up},AxesLabel->{"nu","rho"}],
Plot3D[func[V0,rho,Sqrt[InitialV0]],{V0,V0down,V0up/4},{rho,\[Rho]down,\[Rho]up},AxesLabel->{"V0","rho"}]}
]



(* ::Input::Initialization:: *)
HestonFromBilogPackaged[S1_,S2_,\[Sigma]1_,\[Sigma]2_,Correl12_,T_,\[Lambda]_,LT_,\[Lambda]smooth_]:=
Module[{strikes,Stdev,pricegoaltable,WeightList,nbsteps,scale,microratio,nbstrike,ss,\[Rho],\[Nu],InitialV0,
\[Rho]down=-0.9,\[Rho]up=0.9,\[Nu]down=0.000001,\[Nu]up,V0down,V0up,StandardizedNuMax=2},
InitialV0=S1^2 \[Sigma]1^2+S2^2 \[Sigma]2^2-2Correl12 S1 S2 \[Sigma]1 \[Sigma]2;
V0down=InitialV0 0.95;V0up=10 InitialV0;\[Nu]up=StandardizedNuMax Sqrt[InitialV0];;
Stdev=Sqrt[InitialV0 T];
Print["*****************Inside HestonFromBilogPackaged"];
Print["InitialV0=",InitialV0," \[Nu]up=",\[Nu]up," Stdev(pour le calcul des strike)=",Stdev];
strikes={- Stdev/3,-Stdev/6,0,Stdev/6,Stdev/3};
Print["strikes=",strikes];
nbstrike=Length[strikes];
pricegoaltable=Table[LogNormalSpreadOption[S1,S2,\[Sigma]1,\[Sigma]2,Correl12,strikes[[i]],T,12],{i,1,nbstrike}];
Print["pricegoaltable=",pricegoaltable];
WeightList=Table[1,{i,1,nbstrike}];nbsteps=40;scale=8;
microratio=5 T^(1/2);
ss=NormalHestonSmileCalibratePackaged[strikes,pricegoaltable,WeightList,S1-S2,\[Lambda],LT,T,nbsteps,scale,microratio,InitialV0,StandardizedNuMax,\[Lambda]smooth];
Print["  HestonFromBilogPackaged: optimisation results:",ss];
{ControleVariable[ss[[2,1]],V0down,V0up,\[Lambda]smooth],ControleVariable[ss[[2,2]],\[Rho]down,\[Rho]up,\[Lambda]smooth],ControleVariable[ss[[2,3]],\[Nu]down,\[Nu]up,\[Lambda]smooth]}
]


(* ::Input::Initialization:: *)
HestonFromBilogViewPb[S1_,S2_,\[Sigma]1_,\[Sigma]2_,Correl12_,T_,\[Lambda]_,LT_,\[Lambda]smooth_]:=
Module[{strikes,Stdev,pricegoaltable,WeightList,nbsteps,scale,microratio,nbstrike,ss,\[Rho],\[Nu],NewWeightList,func,Vn,\[Rho]n,\[Nu]n,InitialV0,func1,
\[Rho]down=-0.9,\[Rho]up=0.9,\[Nu]down=0.000001,\[Nu]up=0.1,V0down=0.0000001,V0up=0.1},
InitialV0=S1^2 \[Sigma]1^2+S2^2 \[Sigma]2^2-2Correl12 S1 S2 \[Sigma]1 \[Sigma]2;
Stdev=Sqrt[InitialV0 T];
Print["InitialV0=",InitialV0,"  Stdev(pour le calcul des strike)=",Stdev];
strikes={- Stdev/3,-Stdev/6,0,Stdev/6,Stdev/3};
strikes={0};
Print["strikes=",strikes];
nbstrike=Length[strikes];
pricegoaltable=Table[LogNormalSpreadOption[S1,S2,\[Sigma]1,\[Sigma]2,Correl12,strikes[[i]],T,12],{i,1,nbstrike}];
Print["pricegoaltable=",pricegoaltable];
WeightList=Table[1,{i,1,nbstrike}];nbsteps=40;scale=8;
microratio=5 T^(1/2);
NewWeightList=Table[WeightList[[i]]/NormalCallVega[S1-S2,strikes[[i]],T,Sqrt[InitialV0]],{i,1,Length[WeightList]}];
Print["NewWeightList=",NewWeightList];
func=Function[{V1,\[Rho]1,\[Nu]1},Module[{ff=DerivativeHestonNormalCall[\[Rho]1,\[Lambda],LT,\[Nu]1,V1,S1-S2,strikes,T,nbsteps,scale,microratio,0]},
Sum[NewWeightList[[i]](pricegoaltable[[i]]-ff[[1,i]])^2,{i,1,Length[strikes]}]]];
func1=Function[{V1,\[Rho]1,\[Nu]1},Module[{ff=DerivativeHestonNormalCall[\[Rho]1,\[Lambda],LT,\[Nu]1,V1,S1-S2,strikes,T,nbsteps,scale,microratio,0]},
Sum[ff[[1,i]],{i,1,Length[strikes]}]]];
Vn=InitialV0;
{{Plot3D[func[InitialV0/3,\[Rho]n,\[Nu]n],{\[Rho]n,-0.9,0.9},{\[Nu]n,0.0000001,0.1}],Plot3D[func[InitialV0,\[Rho]n,\[Nu]n],{\[Rho]n,-0.9,0.9},{\[Nu]n,0.0000001,0.1}],Plot3D[func[3 InitialV0,\[Rho]n,\[Nu]n],{\[Rho]n,-0.9,0.9},{\[Nu]n,0.0000001,0.1}]},
{Plot3D[func1[InitialV0/3,\[Rho]n,\[Nu]n],{\[Rho]n,-0.9,0.9},{\[Nu]n,0.0000001,0.1}],Plot3D[func1[InitialV0,\[Rho]n,\[Nu]n],{\[Rho]n,-0.9,0.9},{\[Nu]n,0.0000001,0.1}],Plot3D[func1[3 InitialV0,\[Rho]n,\[Nu]n],{\[Rho]n,-0.9,0.9},{\[Nu]n,0.0000001,0.1}]}}
]


(* ::Input::Initialization:: *)
HestonFromBilogMiniViewPb[S1_,S2_,\[Sigma]1_,\[Sigma]2_,Correl12_,T_,\[Lambda]_,LT_,\[Lambda]smooth_]:=
Module[{strikes,Stdev,pricegoaltable,WeightList,nbsteps,scale,microratio,nbstrike,ss,\[Rho],\[Nu],NewWeightList,func,Vn,\[Rho]n,\[Nu]n,InitialV0,func1,
\[Rho]down=-0.9,\[Rho]up=0.9,\[Nu]down=0.000001,\[Nu]up=0.1,V0down=0.0000001,V0up=0.1},
InitialV0=S1^2 \[Sigma]1^2+S2^2 \[Sigma]2^2-2Correl12 S1 S2 \[Sigma]1 \[Sigma]2;
Stdev=Sqrt[InitialV0 T];
Print["InitialV0=",InitialV0,"  Stdev(pour le calcul des strike)=",Stdev];
strikes={- Stdev/3,-Stdev/6,0,Stdev/6,Stdev/3};
strikes={0};
Print["strikes=",strikes];
nbstrike=Length[strikes];
pricegoaltable=Table[LogNormalSpreadOption[S1,S2,\[Sigma]1,\[Sigma]2,Correl12,strikes[[i]],T,12],{i,1,nbstrike}];
Print["pricegoaltable=",pricegoaltable];
WeightList=Table[1,{i,1,nbstrike}];nbsteps=40;scale=8;
microratio=5 T^(1/2);
NewWeightList=Table[WeightList[[i]]/NormalCallVega[S1-S2,strikes[[i]],T,Sqrt[InitialV0]],{i,1,Length[WeightList]}];
Print["NewWeightList=",NewWeightList];
func=Function[{V1,\[Rho]1,\[Nu]1},Module[{ff=DerivativeHestonNormalCall[\[Rho]1,\[Lambda],LT,\[Nu]1,V1,S1-S2,strikes,T,nbsteps,scale,microratio,0]},
Sum[ff[[1,i]],{i,1,Length[strikes]}]]];
Vn=InitialV0;
Plot3D[func[1.1InitialV0,\[Rho]n,\[Nu]n],{\[Rho]n,-0.9,0.9},{\[Nu]n,0.0000001,0.1}]
]


(* ::Input::Initialization:: *)
AlphaDigitaleCorr={
{1,0,0,0,0,0,rho1,0,0,0,0,0},
{0,1,0,0,0,0,0,rho2,0,0,0,0},
{0,0,1,0,0,0,0,0,rho3,0,0,0},
{0,0,0,1,0,0,0,0,0,rho4,0,0},
{0,0,0,0,1,0,0,0,0,0,rho5,0},
{0,0,0,0,0,1,0,0,0,0,0,rhoi},
{rho1,0,0,0,0,0,1,0,0,0,0,0},
{0,rho2,0,0,0,0,0,1,0,0,0,0},
{0,0,rho3,0,0,0,0,0,1,0,0,0},
{0,0,0,rho4,0,0,0,0,0,1,0,0},
{0,0,0,0,rho5,0,0,0,0,0,1,0},
{0,0,0,0,0,rhoi,0,0,0,0,0,1}
};


(* ::Input::Initialization:: *)
AlphaDigitaleDiff[x_]:=
D[x,S1]{alpha11 Sqrt[V1]S1,alpha12 Sqrt[V2]S1,alpha13 Sqrt[V3]S1,alpha14 Sqrt[V4]S1,Sqrt[V5] S1,0,0,0,0,0,0,0}+
D[x,Si]{alphai1 Sqrt[V1]Si,alphai2 Sqrt[V2]Si,alphai3 Sqrt[V3]Si,alphai4 Sqrt[V4]Si,0,Sqrt[Vi] Si,0,0,0,0,0,0}+
D[x,V1]{0,0,0,0,0,0,kappaV1 Sqrt[V1],0,0,0,0,0}+
D[x,V2]{0,0,0,0,0,0,0,kappaV2 Sqrt[V2],0,0,0,0}+
D[x,V3]{0,0,0,0,0,0,0,0,kappaV3 Sqrt[V3],0,0,0}+
D[x,V4]{0,0,0,0,0,0,0,0,0,kappaV4 Sqrt[V4],0,0}+
D[x,V5]{0,0,0,0,0,0,0,0,0,0,kappaV5 Sqrt[V5],0}+
D[x,Vi]{0,0,0,0,0,0,0,0,0,0,0,kappaVi Sqrt[Vi]}


(* ::Input::Initialization:: *)
zeroRuleU1i={kappaV1->0,kappaV2->0,kappaV3->0,kappaV4->0,kappaV5->0,kappaVi->0};


(* ::Input::Initialization:: *)
CompuputePureFunctionQuadriBiSuperHestonSpreadU1iObservable[spread_]:=
Module[{VS,VarVS,VarVS0,CoVarVS,CoVarVS0},
VS=Simplify[AlphaDigitaleDiff[spread] . (AlphaDigitaleCorr . AlphaDigitaleDiff[spread])];
VarVS=Simplify[AlphaDigitaleDiff[VS] . (AlphaDigitaleCorr . AlphaDigitaleDiff[VS])];
VarVS0=VarVS/.zeroRuleU1i;
CoVarVS=Simplify[AlphaDigitaleDiff[VS] . (AlphaDigitaleCorr . AlphaDigitaleDiff[spread])];
CoVarVS0=CoVarVS /.zeroRuleU1i;
Apply[Function,{{S1,Si,
alpha11,alpha12,alpha13,alpha14,
alphai1,alphai2,alphai3,alphai4,
rho1,kappaV1,V1,
rho2,kappaV2,V2,
rho3,kappaV3,V3,
rho4,kappaV4,V4,
rho5,kappaV5,V5,
rhoi,kappaVi,Vi},
{VS,Simplify[VarVS-VarVS0],Simplify[CoVarVS-CoVarVS0],Simplify[VarVS0],Simplify[CoVarVS0]}}]];


(* ::Input::Initialization:: *)
AlphaDigitaleObservable1iz=CompuputePureFunctionQuadriBiSuperHestonSpreadU1iObservable[(Si-S1)];


(* ::Input::Initialization:: *)
VSSpread1iz[\[Rho]1_,\[Nu]1_,V01_,\[Rho]2_,\[Nu]2_,V02_,\[Rho]3_,\[Nu]3_,V03_,\[Rho]4_,\[Nu]4_,V04_,\[Rho]5_,\[Nu]5_,V05_,\[Rho]i_,\[Nu]i_,V0i_]:=AlphaDigitaleObservable1iz[S1,Si,
alpha11,alpha12,alpha13,alpha14,
alphai1,alphai2,alphai3,alphai4,
rho1,kappaV1,V1,
rho2,kappaV2,V2,
rho3,kappaV3,V3,
rho4,kappaV4,V4,
rho5,kappaV5,V5,
rhoi,kappaVi,Vi][[1]]


(* ::Input::Initialization:: *)
VarVSSpread1iz[\[Rho]1_,\[Nu]1_,V01_,\[Rho]2_,\[Nu]2_,V02_,\[Rho]3_,\[Nu]3_,V03_,\[Rho]4_,\[Nu]4_,V04_,\[Rho]5_,\[Nu]5_,V05_,\[Rho]i_,\[Nu]i_,V0i_]:=AlphaDigitaleObservable1iz[S1,Si,
alpha11,alpha12,alpha13,alpha14,
alphai1,alphai2,alphai3,alphai4,
rho1,kappaV1,V1,
rho2,kappaV2,V2,
rho3,kappaV3,V3,
rho4,kappaV4,V4,
rho5,kappaV5,V5,
rhoi,kappaVi,Vi][[2]]


(* ::Input::Initialization:: *)
CoVarVSSpread1iz[\[Rho]1_,\[Nu]1_,V01_,\[Rho]2_,\[Nu]2_,V02_,\[Rho]3_,\[Nu]3_,V03_,\[Rho]4_,\[Nu]4_,V04_,\[Rho]5_,\[Nu]5_,V05_,\[Rho]i_,\[Nu]i_,V0i_]:=AlphaDigitaleObservable1iz[S1,Si,
alpha11,alpha12,alpha13,alpha14,
alphai1,alphai2,alphai3,alphai4,
rho1,kappaV1,V1,
rho2,kappaV2,V2,
rho3,kappaV3,V3,
rho4,kappaV4,V4,
rho5,kappaV5,V5,
rhoi,kappaVi,Vi][[3]]


(* ::Input::Initialization:: *)
BiSuperDigitaleCorr={
{1,0,0,rho1,0,0},
{0,1,0,0,rho2,0},
{0,0,1,0,0,rho3},
{rho1,0,0,1,0,0},
{0,rho2,0,0,1,0},
{0,0,rho3,0,0,1}
};


(* ::Input::Initialization:: *)
BiSuperDigitaleDiff[x_]:=
D[x,S1]{Sqrt[V1] S1,alpha Sqrt[V2]S1,0,0,0,0}+
D[x,S2]{0,beta Sqrt[V2]S2, Sqrt[V3]S2,0,0,0}+
D[x,V1]{0,0,0,kappaV1 Sqrt[V1],0,0}+
D[x,V2]{0,0,0,0,kappaV2 Sqrt[V2],0}+
D[x,V3]{0,0,0,0,0,kappaV3 Sqrt[V3]}


(* ::Input::Initialization:: *)
zeroRule={kappaV1->0,kappaV2->0,kappaV3->0};


(* ::Input::Initialization:: *)
CompuputePureFunctionBiSuperHestonSpreadU1iObservable[spread_]:=
Module[{VS,VarVS,VarVS0,CoVarVS,CoVarVS0},
VS=Simplify[BiSuperDigitaleDiff[spread] . (BiSuperDigitaleCorr . BiSuperDigitaleDiff[spread])];
VarVS=Simplify[BiSuperDigitaleDiff[VS] . (BiSuperDigitaleCorr . BiSuperDigitaleDiff[VS])];
VarVS0=VarVS/.zeroRule;
CoVarVS=Simplify[BiSuperDigitaleDiff[VS] . (BiSuperDigitaleCorr . BiSuperDigitaleDiff[spread])];
CoVarVS0=CoVarVS /.zeroRule;
Apply[Function,{{S1,S2,
alpha,beta,
rho1,kappaV1,V1,
rho2,kappaV2,V2,
rho3,kappaV3,V3},
{VS,Simplify[VarVS-VarVS0],Simplify[CoVarVS-CoVarVS0],Simplify[VarVS0],Simplify[CoVarVS0]}}]];


(* ::Input::Initialization:: *)
BiSuperDigitaleObservable1iz=CompuputePureFunctionBiSuperHestonSpreadU1iObservable[(S2-S1)];


(* ::Input::Initialization:: *)
ComputeEquivalentBilogFromAlpha[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,T_]:=
Module[{equivalent\[Sigma]1,equivalent\[Sigma]2,equivalent\[Rho]},
equivalent\[Sigma]1=Sqrt[\[Alpha]11^2 V1+\[Alpha]12^2 V2+\[Alpha]13^2 V3+\[Alpha]14^2 V4+V5];
equivalent\[Sigma]2=Sqrt[\[Alpha]i1^2 V1+\[Alpha]i2^2 V2+\[Alpha]i3^2 V3+\[Alpha]i4^2 V4+Vi];
equivalent\[Rho]=(\[Alpha]11 \[Alpha]i1 V1+\[Alpha]12 \[Alpha]i2 V2+\[Alpha]13 \[Alpha]i3 V3+\[Alpha]14 \[Alpha]i4 V4)/(equivalent\[Sigma]1 equivalent\[Sigma]2);
{equivalent\[Sigma]1,equivalent\[Sigma]2,equivalent\[Rho]}
]



(* ::Input::Initialization:: *)
AlphaGenericComputeSpreadOption[S1_,S2_,Sig1_,Sig2_,Correl12_,VS_,VarVSIncremental_,CoVarSVSIncremental_,LTFactorS_,\[Lambda]S_,SpreadStrikes_,\[Tau]_,LimitGindinkin_,printflag_]:=Module[{\[Rho]projet\[EAcute],numinimum,rhominimum,V0projet\[EAcute],V0minimim,V0Effectif,VarVSTotal,CoVarSVSTotal,\[Nu]projet\[EAcute],prices,
nbsteps=10,scale=8,microratio=20},
(* Calcul de l'equivalent lognormal *)
{V0minimim,rhominimum,numinimum}=HestonFromBilog[S1,S2,Sig1,Sig2,Correl12,\[Tau],\[Lambda]S,LTFactorS];
If[printflag==1 || MemberQ[printflag,1] ,Print["Mode 2 :  Numinimum=",numinimum," rhominimum= ",rhominimum," V0minimim=",V0minimim]];
(* Calcul des parametres totaux *)
V0Effectif=V0minimim;
VarVSTotal=VarVSIncremental+numinimum^2 V0minimim;
CoVarSVSTotal=CoVarSVSIncremental+rhominimum V0minimim numinimum;
\[Rho]projet\[EAcute]=CoVarSVSTotal/Sqrt[V0minimim VarVSTotal];\[Nu]projet\[EAcute]=Sqrt[VarVSTotal/V0minimim];V0projet\[EAcute]=V0minimim;

If[printflag==1 || MemberQ[printflag,1] ,Print["Normal Heston Parameters=",{{"S0",S1-S2},{"V0",V0projet\[EAcute]},{"\[Theta]",V0projet\[EAcute] LTFactorS },{"\[Lambda]v",\[Lambda]S},{"\[Rho]",\[Rho]projet\[EAcute]},{"\[Nu]",\[Nu]projet\[EAcute]},
{"\[Nu] normalized",\[Nu]projet\[EAcute]/Sqrt[V0projet\[EAcute]]},{"standard dev equi.",Sqrt[V0projet\[EAcute]]}} //MatrixForm]];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda]S,LTFactorS,\[Nu]projet\[EAcute],V0Effectif,S1-S2,SpreadStrikes,\[Tau],nbsteps,scale,microratio,0][[1]];
If[printflag==1 || MemberQ[printflag,1] ,Print["prices=",prices]];
prices
]


(* ::Input::Initialization:: *)
SmileAlphaSpreadOption[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_,T_,LimitGindinkin_,printflag_,bilogHestonFlag_]:=SmileAlphaSpreadOptionlist[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,LT,\[Lambda],{K},T,LimitGindinkin,printflag,bilogHestonFlag][[1]]


(* ::Input::Initialization:: *)
SmileAlphaSpreadOption[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_List,T_,LimitGindinkin_,printflag_,bilogHestonFlag_]:=SmileAlphaSpreadOptionlist[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,LT,\[Lambda],K,T,LimitGindinkin,printflag,bilogHestonFlag]


(* ::Input::Initialization:: *)
SmileAlphaSpreadOptionlist[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_List,T_,LimitGindinkin_,printflag_,bilogHestonFlag_]:=Module[{\[Rho]projet\[EAcute],\[Nu]projet\[EAcute],prices,VarVSIncrementale,CoVarSVSIncrementale,VS,Sig1,Sig2,Correl12,numinimum,rhominimum,\[Lambda]smooth,VarVSTotal,Vmultiplicator,CoVarSVSTotal,digitaleprices,forward,V0projet\[EAcute],V0minimim,nbsteps=20,scale=10,microratio=20},
Sig1=Sqrt[\[Alpha]11^2 V1+\[Alpha]12^2 V2+\[Alpha]13^2 V3+\[Alpha]14^2 V4+V5];Sig2=Sqrt[\[Alpha]i1^2 V1+\[Alpha]i2^2 V2+\[Alpha]i3^2 V3+\[Alpha]i4^2 V4+Vi];Correl12= (\[Alpha]11 \[Alpha]i1  V1+\[Alpha]12 \[Alpha]i2  V2+\[Alpha]13 \[Alpha]i3  V3+\[Alpha]14 \[Alpha]i4  V4)/(Sig1 Sig2);Vmultiplicator=Exp[0.026958633519421456 T-0.017202498337524928];\[Lambda]smooth=10;
Print["S1,Si,Sig1,Sig2,Correl12,T=",{S1,Si,Sig1,Sig2,Correl12,T}];
Switch[bilogHestonFlag,
0,
{V0minimim,rhominimum,numinimum}=HestonFromBilog[S1,Si,Sig1,Sig2,Correl12,T,\[Lambda],LT],
1,
{V0minimim,rhominimum,numinimum}=HestonFromBilogV0Fixed[S1,Si,Sig1,Sig2,Correl12,T,\[Lambda],LT,Vmultiplicator],
2,
{V0minimim,rhominimum,numinimum}=HestonFromBilogPackaged[S1,Si,Sig1,Sig2,Correl12,T,\[Lambda],LT,\[Lambda]smooth]];
If[printflag==1 || MemberQ[printflag,1] ,Print["V0minimim=",V0minimim," rhominimum= ",rhominimum," Numinimum=",numinimum]];
If[printflag==1 || MemberQ[printflag,1] ,Print["VSminimale=",V0minimim," VarVSminimale=",numinimum^2 V0minimim," CoVarSVSminimale=",rhominimum V0minimim numinimum]];
{VS,VarVSIncrementale,CoVarSVSIncrementale}=AlphaDigitaleObservable1iz[S1,Si,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi];
If[printflag==1 || MemberQ[printflag,1] ,Print["VSBlack=",VS," VarVSIncrementale=",VarVSIncrementale," CoVarSVSIncrementale=",CoVarSVSIncrementale]];
VarVSTotal=VarVSIncrementale+numinimum^2 V0minimim;
CoVarSVSTotal=CoVarSVSIncrementale+rhominimum V0minimim numinimum;
If[printflag==1 || MemberQ[printflag,1] ,Print["VSTotal=",V0minimim," VarVSTotal=",VarVSTotal," CoVarSVSTotal= ",CoVarSVSTotal]];
\[Rho]projet\[EAcute]=CoVarSVSTotal/Sqrt[V0minimim VarVSTotal];\[Nu]projet\[EAcute]=Sqrt[VarVSTotal/V0minimim];V0projet\[EAcute]=V0minimim;
forward=S1-Si;
If[printflag==1 || MemberQ[printflag,1] ,Print["Normal Heston Parameters=",{{"S0",forward},{"V0",V0projet\[EAcute]},{"\[Rho]",\[Rho]projet\[EAcute]},{"\[Nu]",\[Nu]projet\[EAcute]},
{"standard dev equi.",Sqrt[VS]},{"\[Nu] normalized",\[Nu]projet\[EAcute]/Sqrt[VS]}} //MatrixForm]];
DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],V0projet\[EAcute],S1-Si,K,T,nbsteps,scale,microratio,0][[1]]
]


(* ::Input::Initialization:: *)
LogaritmOfNormalHestonFondamentalTransform[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,\[Omega]_,\[Tau]_]:=Module[{\[Zeta],\[Psi]p ,\[Psi]m,A,B,arg\[Zeta]},
\[Zeta]=Sqrt[(\[Lambda]v+\[Rho] \[Kappa] I \[Omega])^2+\[Kappa]^2 ( \[Omega]^2)];
\[Psi]p =-(\[Lambda]v+\[Rho] \[Kappa]  I \[Omega])+\[Zeta];
\[Psi]m =(\[Lambda]v+\[Rho] \[Kappa]  I \[Omega])+\[Zeta];
A=-(( \[Theta]v \[Lambda]v (\[Tau] \[Psi]p+2 Log[(\[Psi]m+E^(-\[Zeta] \[Tau]) \[Psi]p)/(2\[Zeta])]))/ (\[Kappa]^2)   );
B=( -( \[Omega]^2)(1-E^(-\[Zeta]  \[Tau])))/(\[Psi]m+\[Psi]p E^(-\[Zeta]  \[Tau]));
A+B V]


(* ::Input::Initialization:: *)
D2=D[LogaritmOfNormalHestonFondamentalTransform[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Omega],\[Tau]],{\[Omega],2}];
D2LogNormalHestonFondamentalTransform=Function[{\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Tau]},Evaluate[1/I^2 D2/. \[Omega]->0]];


(* ::Input::Initialization:: *)
D2LogNormalHestonFondamentalTransform=Function[{\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Tau]},Evaluate[Simplify[D2LogNormalHestonFondamentalTransform[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Tau]]]]];


(* ::Input::Initialization:: *)
LogBiSuperLogNormalHestonFondamentalTransform[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,\[Alpha]2_,\[Beta]2_,Z1_,Z2_,\[Tau]_]:=
Module[{\[Zeta]1,\[Psi]p1 ,\[Psi]m1,A1,\[Zeta]2,\[Psi]p2 ,\[Psi]m2,A2,\[Zeta]3,\[Psi]p3 ,\[Psi]m3,A3,c},
\[Zeta]1=Sqrt[(\[Lambda]v1+\[Rho]1 \[Kappa]1 I Z1)^2+\[Kappa]1^2 ( Z1^2-I Z1)];
\[Psi]p1 =-(\[Lambda]v1+\[Rho]1 \[Kappa]1 I Z1)+\[Zeta]1;
\[Psi]m1 =(\[Lambda]v1+\[Rho]1 \[Kappa]1  I Z1)+\[Zeta]1;
A1=( -( Z1^2-I Z1)(1-E^(-\[Zeta]1  \[Tau])))/(\[Psi]m1+\[Psi]p1 E^(-\[Zeta]1  \[Tau]));
\[Zeta]2=\[Sqrt]((\[Lambda]v2+\[Rho]2 \[Kappa]2 I (Z1 \[Alpha]2+Z2 \[Beta]2))^2+\[Kappa]2^2 ( Z1 (-I+Z1) \[Alpha]2^2+2 Z1 Z2 \[Alpha]2 \[Beta]2+Z2 (-I+Z2) \[Beta]2^2));
\[Psi]p2 =-(\[Lambda]v2+\[Rho]2 \[Kappa]2  I (Z1 \[Alpha]2+Z2 \[Beta]2))+\[Zeta]2;
\[Psi]m2 =(\[Lambda]v2+\[Rho]2 \[Kappa]2  I (Z1 \[Alpha]2+Z2 \[Beta]2))+\[Zeta]2;
A2=( -( Z1 (-I+Z1) \[Alpha]2^2+2 Z1 Z2 \[Alpha]2 \[Beta]2+Z2 (-I+Z2) \[Beta]2^2)(1-E^(-\[Zeta]2  \[Tau])))/(\[Psi]m2+\[Psi]p2 E^(-\[Zeta]2  \[Tau]));
\[Zeta]3=Sqrt[(\[Lambda]v3+\[Rho]3 \[Kappa]3 I Z2)^2+\[Kappa]3^2 ( Z2^2-I Z2)];
\[Psi]p3 =-(\[Lambda]v3+\[Rho]3 \[Kappa]3  I Z2)+\[Zeta]3;
\[Psi]m3 =(\[Lambda]v3+\[Rho]3 \[Kappa]3  I Z2)+\[Zeta]3;
A3=( -( Z2^2-I Z2)(1-E^(-\[Zeta]3  \[Tau])))/(\[Psi]m3+\[Psi]p3 E^(-\[Zeta]3  \[Tau]));

c=-(( \[Theta]v1 \[Lambda]v1 (\[Tau] \[Psi]p1+2 Log[(\[Psi]m1+E^(-\[Zeta]1 \[Tau]) \[Psi]p1)/(2\[Zeta]1)]))/ (\[Kappa]1^2)   )-( \[Theta]v2 \[Lambda]v2 (\[Tau] \[Psi]p2+2 Log[(\[Psi]m2+E^(-\[Zeta]2 \[Tau]) \[Psi]p2)/(2\[Zeta]2)]))/ (\[Kappa]2^2)   -( \[Theta]v3 \[Lambda]v3 (\[Tau] \[Psi]p3+2 Log[(\[Psi]m3+E^(-\[Zeta]3 \[Tau]) \[Psi]p3)/(2\[Zeta]3)]))/ (\[Kappa]3^2)   ;
c+A1 V1+A2 V2+A3 V3]


(* ::Input::Initialization:: *)
D1X=D[LogBiSuperLogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Alpha]2,\[Beta]2,Z1,Z2,\[Tau]],Z1];
D1XBiSuperLogNormalHestonFondamentalTransform=Function[{\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Alpha]2,\[Beta]2,\[Tau]},Evaluate[Simplify[1/I D1X /.{Z1->0,Z2->0},\[Lambda]v1>0&&\[Lambda]v2>0&&\[Lambda]v3>0]]];


(* ::Input::Initialization:: *)
D1Y=D[LogBiSuperLogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Alpha]2,\[Beta]2,Z1,Z2,\[Tau]],Z2];
D1YBiSuperLogNormalHestonFondamentalTransform=Function[{\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Alpha]2,\[Beta]2,\[Tau]},Evaluate[Simplify[1/I D1Y/.{Z1->0,Z2->0},\[Lambda]v1>0&&\[Lambda]v2>0&&\[Lambda]v3>0]]];


(* ::Input::Initialization:: *)
D2XX=D[LogBiSuperLogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Alpha]2,\[Beta]2,Z1,Z2,\[Tau]],{Z1,2}];
D2XXBiSuperLogNormalHestonFondamentalTransform=Function[{\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Alpha]2,\[Beta]2,\[Tau]},Evaluate[Simplify[1/I^2 D2XX/.{Z1->0,Z2->0},\[Lambda]v1>0&&\[Lambda]v2>0&&\[Lambda]v3>0]]];


(* ::Input::Initialization:: *)
D2YY=D[LogBiSuperLogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Alpha]2,\[Beta]2,Z1,Z2,\[Tau]],{Z2,2}];
D2YYBiSuperLogNormalHestonFondamentalTransform=Function[{\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Alpha]2,\[Beta]2,\[Tau]},Evaluate[Simplify[1/I^2 D2YY/.{Z1->0,Z2->0},\[Lambda]v1>0&&\[Lambda]v2>0&&\[Lambda]v3>0]]];


(* ::Input::Initialization:: *)
D2XY=D[LogBiSuperLogNormalHestonFondamentalTransform[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Alpha]2,\[Beta]2,Z1,Z2,\[Tau]],Z1,Z2];
D2XYBiSuperLogNormalHestonFondamentalTransform=Function[{\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,\[Alpha]2,\[Beta]2,\[Tau]},Evaluate[Simplify[1/I^2 D2XY/.{Z1->0,Z2->0},\[Lambda]v1>0&&\[Lambda]v2>0&&\[Lambda]v3>0]]];


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1U1FondamentalTransform[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,
\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,z_,\[Lambda]_,LT_,\[Tau]_]:=
Module[{A1,B1,A2,B2,A3,B3,A4,B4,A5,B5,Ai,Bi,\[Theta]1,\[Theta]2,\[Theta]3,\[Theta]4,\[Theta]5,\[Theta]i,\[Beta]1,\[Beta]2,\[Beta]3,\[Beta]4,\[Beta]5,\[Beta]i},
\[Theta]1= V1 LT;\[Theta]2=V2  LT;\[Theta]3=V3  LT;\[Theta]4= V4 LT;\[Theta]5=V5 LT;\[Theta]i=Vi LT;
\[Beta]1=\[Alpha]11^2/2;
\[Beta]2=\[Alpha]12^2/2;
\[Beta]3=\[Alpha]13^2/2;
\[Beta]4=\[Alpha]14^2/2;
\[Beta]5=1/2;
\[Beta]i=0;
{A1,B1}=RiccatiSolveP[\[Kappa]1,(\[Lambda] +  I z \[Kappa]1 \[Rho]1),(-I 2\[Beta]1 z-\[Alpha]11^2 z^2),\[Lambda],\[Theta]1,\[Tau]];
{A2,B2}=RiccatiSolveP[\[Kappa]2,(\[Lambda] +  I z \[Kappa]2 \[Rho]2),(-I 2\[Beta]2 z-\[Alpha]12^2 z^2),\[Lambda],\[Theta]2,\[Tau]];
{A3,B3}=RiccatiSolveP[\[Kappa]3,(\[Lambda] +  I z \[Kappa]3 \[Rho]3),(-I 2\[Beta]3 z-\[Alpha]13^2 z^2),\[Lambda],\[Theta]3,\[Tau]];
{A4,B4}=RiccatiSolveP[\[Kappa]4,(\[Lambda]+  I z \[Kappa]4 \[Rho]4),(-I 2\[Beta]4 z-\[Alpha]14^2 z^2),\[Lambda],\[Theta]4,\[Tau]];
{A5,B5}=RiccatiSolveP[\[Kappa]5,(\[Lambda]),(-I 2\[Beta]5 z),\[Lambda],\[Theta]5,\[Tau]];
{Ai,Bi}=RiccatiSolveP[\[Kappa]i,(\[Lambda]+  I z \[Kappa]i \[Rho]i),(-I 2\[Beta]i z-z^2),\[Lambda],\[Theta]i,\[Tau]];
E^(A1+A2+A3+A4+A5+Ai+B1 V1+B2 V2 +B3 V3 +B4 V4+B5 V5+Bi Vi )]



(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1UiFondamentalTransform[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,
\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,z_,\[Lambda]_,LT_,\[Tau]_]:=
Module[{A1,B1,A2,B2,A3,B3,A4,B4,A5,B5,Ai,Bi,\[Theta]1,\[Theta]2,\[Theta]3,\[Theta]4,\[Theta]5,\[Theta]i,\[Beta]1,\[Beta]2,\[Beta]3,\[Beta]4,\[Beta]5,\[Beta]i},
\[Theta]1= V1 LT;\[Theta]2=V2  LT;\[Theta]3=V3  LT;\[Theta]4= V4 LT;\[Theta]5=V5 LT;\[Theta]i=Vi LT;
\[Beta]1=-(\[Alpha]i1^2/2)+\[Alpha]11 \[Alpha]i1;
\[Beta]2=-(\[Alpha]i2^2/2)+\[Alpha]12 \[Alpha]i2;
\[Beta]3=-(\[Alpha]i3^2/2)+\[Alpha]13 \[Alpha]i3;
\[Beta]4=-(\[Alpha]i4^2/2)+\[Alpha]14 \[Alpha]i4;
\[Beta]5=0;
\[Beta]i=-(1/2);
{A1,B1}=RiccatiSolveP[\[Kappa]1,(\[Lambda] +  I z \[Kappa]1 \[Rho]1),(-I 2 \[Beta]1 z-\[Alpha]i1^2 z^2),\[Lambda],\[Theta]1,\[Tau]];
{A2,B2}=RiccatiSolveP[\[Kappa]2,(\[Lambda] +  I z \[Kappa]2 \[Rho]2),(-I 2\[Beta]2 z-\[Alpha]i2^2 z^2),\[Lambda],\[Theta]2,\[Tau]];
{A3,B3}=RiccatiSolveP[\[Kappa]3,(\[Lambda] +  I z \[Kappa]3 \[Rho]3),(-I 2\[Beta]3 z-\[Alpha]i3^2 z^2),\[Lambda],\[Theta]3,\[Tau]];
{A4,B4}=RiccatiSolveP[\[Kappa]4,(\[Lambda]+  I z \[Kappa]4 \[Rho]4),(-I 2\[Beta]4 z-\[Alpha]i4^2 z^2),\[Lambda],\[Theta]4,\[Tau]];
{A5,B5}=RiccatiSolveP[\[Kappa]5,(\[Lambda]+  I z \[Kappa]5 \[Rho]4),(-I 2\[Beta]5 z-z^2),\[Lambda],\[Theta]5,\[Tau]];
{Ai,Bi}=RiccatiSolveP[\[Kappa]i,(\[Lambda]),(-I 2\[Beta]i z),\[Lambda],\[Theta]i,\[Tau]];
E^(A1+A2+A3+A4+A5+Ai+B1 V1+B2 V2 +B3 V3 +B4 V4+B5 V5+Bi Vi )]



(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1U1CallIntegrand[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,
\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S0_,K_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0]) AlphaDigitaleMeasureS1U1FondamentalTransform[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Omega],\[Lambda],LT,T]LogNormalCallPayOffFourierTransform[K,\[Omega]]]


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1UiCallIntegrand[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,
\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S0_,K_,T_,\[Omega]_]:=Re[E^(-I \[Omega]  Log[S0]) AlphaDigitaleMeasureS1UiFondamentalTransform[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Omega],\[Lambda],LT,T]LogNormalCallPayOffFourierTransform[K,\[Omega]]]


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1U1CallN[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S0_,K_,T_]:=
-1/\[Pi] Re[Module[{\[Lambda]s=1.25,\[Omega]},
NIntegrate[AlphaDigitaleMeasureS1U1CallIntegrand[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T,\[Omega] +\[Lambda]s I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1UiCallN[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S0_,K_,T_]:=
-1/\[Pi] Re[Module[{\[Lambda]s=1.25,\[Omega]},
NIntegrate[AlphaDigitaleMeasureS1UiCallIntegrand[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T,\[Omega] +\[Lambda]s I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1U1PutN[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S0_,K_,T_]:=
-(1/\[Pi])Re[Module[{\[Lambda]s=-0.025,\[Omega]},
NIntegrate[AlphaDigitaleMeasureS1U1CallIntegrand[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T,\[Omega] +\[Lambda]s I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1UiPutN[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S0_,K_,T_]:=
-(1/\[Pi])Re[Module[{\[Lambda]s=-0.025,\[Omega]},
NIntegrate[AlphaDigitaleMeasureS1UiCallIntegrand[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T,\[Omega] +\[Lambda]s I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1ForwardU1N[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S0_,K_,T_]:=AlphaDigitaleMeasureS1U1CallN[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T]-AlphaDigitaleMeasureS1U1PutN[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T]+K


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1ForwardUiN[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S0_,K_,T_]:=AlphaDigitaleMeasureS1UiCallN[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T]-AlphaDigitaleMeasureS1UiPutN[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T]+K


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1U1CallAux[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S0_,K_,T_]:=
-(1/\[Pi])Re[Module[{\[Lambda]s=1.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],AlphaDigitaleMeasureS1U1CallIntegrand[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T,\[Omega] +\[Lambda]s I]],LegendreCoeffs[60],LegendreCoeffs[3],10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureS1U1PutAux[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S0_,K_,T_]:=
-(1/\[Pi])Re[Module[{\[Lambda]s=-0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],AlphaDigitaleMeasureS1U1CallIntegrand[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T,\[Omega] +\[Lambda]s I]],LegendreCoeffs[60],LegendreCoeffs[3],10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
AlphaMeasureS1ForwardU1Aux[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S0_,K_,T_]:=AlphaDigitaleMeasureS1U1CallAux[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T]-AlphaDigitaleMeasureS1U1PutAux[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]5,\[Kappa]5,V5,\[Rho]i,\[Kappa]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Lambda],LT,S0,K,T]+K


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureSiForwardU1N[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,S1_,K_,T_]:=AlphaDigitaleMeasureS1ForwardUiN[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]i,\[Kappa]i,Vi,\[Rho]5,\[Kappa]5,V5,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Lambda],LT,S1,K,T]


(* ::Input::Initialization:: *)
AlphaDigitaleMeasureSiForwardUiN[\[Rho]1_,\[Kappa]1_,V1_,\[Rho]2_,\[Kappa]2_,V2_,\[Rho]3_,\[Kappa]3_,V3_,\[Rho]4_,\[Kappa]4_,V4_,\[Rho]5_,\[Kappa]5_,V5_,\[Rho]i_,\[Kappa]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,\[Lambda]_,LT_,Si_,K_,T_]:=AlphaDigitaleMeasureS1ForwardU1N[\[Rho]1,\[Kappa]1,V1,\[Rho]2,\[Kappa]2,V2,\[Rho]3,\[Kappa]3,V3,\[Rho]4,\[Kappa]4,V4,\[Rho]i,\[Kappa]i,Vi,\[Rho]5,\[Kappa]5,V5,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Lambda],LT,Si,K,T]


(* ::Input::Initialization:: *)
IntercalePrice[K1List_,K2List_]:=Module[{nb1=Length[K1List],nb2=Length[K2List],tab,j=1,itab=1,j1=1,j2=1},
tab=Table[0,{i,1,nb1+nb2}];
While[((j1<=nb1)||(j2<=nb2))&&j<=nb1+nb2,
If[itab==1,tab[[j]]=K1List[[j1]]];If[itab==2,tab[[j]]=K2List[[j2]]];
If[itab==1,j1=j1+1;If[j2<=nb2,itab=2],
j2=j2+1;If[j1<=nb1,itab=1]];
j++
];
tab]


(* ::Input::Initialization:: *)
IntercalePrice[KList1_,KList2_,KList3_]:=Module[{m=Length[KList1],list=Table[0,{i,1,3 Length[KList1]}]},
Do[list[[1+3i]]=KList1[[i+1]];list[[2+3i]]=KList2[[i+1]];list[[3+3i]]=KList3[[i+1]];,{i,0,m-1}];
list]


(* ::Input::Initialization:: *)
SmileAlphaDigitale[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_,T_,LimitGindinkin_,printflag_,bilogHestonFlag_]:=SmileAlphaDigitalelist[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,LT,\[Lambda],{K},T,LimitGindinkin,printflag,bilogHestonFlag][[1]]


(* ::Input::Initialization:: *)
SmileAlphaDigitale[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_List,T_,LimitGindinkin_,printflag_,bilogHestonFlag_]:=SmileAlphaDigitalelist[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,LT,\[Lambda],K,T,LimitGindinkin,printflag,bilogHestonFlag]


(* ::Input::Initialization:: *)
SmileAlphaDigitalelist[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_List,T_,LimitGindinkin_,printflag_,bilogHestonFlag_]:=Module[{\[Rho]projet\[EAcute],\[Nu]projet\[EAcute],prices,VarVSIncrementale,CoVarSVSIncrementale,VS,Sig1,Sig2,Correl12,numinimum,rhominimum,VarVSTotal,\[Lambda]smooth,Vmultiplicator,CoVarSVSTotal,digitaleprices,forward,shiftL,CompoundK,V0projet\[EAcute],V0minimim,nbsteps=10,scale=8,microratio=20},

Sig1=Sqrt[\[Alpha]11^2 V1+\[Alpha]12^2 V2+\[Alpha]13^2 V3+\[Alpha]14^2 V4+V5];Sig2=Sqrt[\[Alpha]i1^2 V1+\[Alpha]i2^2 V2+\[Alpha]i3^2 V3+\[Alpha]i4^2 V4+Vi];Correl12= (\[Alpha]11 \[Alpha]i1  V1+\[Alpha]12 \[Alpha]i2  V2+\[Alpha]13 \[Alpha]i3  V3+\[Alpha]14 \[Alpha]i4  V4)/(Sig1 Sig2);
Vmultiplicator=Exp[0.026958633519421456` T-0.017202498337524928`];\[Lambda]smooth=20;
Switch[bilogHestonFlag,
0,
{V0minimim,rhominimum,numinimum}=HestonFromBilog[S1,Si,Sig1,Sig2,Correl12,T,\[Lambda],LT],
1,
{V0minimim,rhominimum,numinimum}=HestonFromBilogV0Fixed[S1,Si,Sig1,Sig2,Correl12,T,\[Lambda],LT,Vmultiplicator],
2,
{V0minimim,rhominimum,numinimum}=HestonFromBilogPackaged[S1,Si,Sig1,Sig2,Correl12,T,\[Lambda],LT,\[Lambda]smooth]];
If[printflag==1 || MemberQ[printflag,1] ,Print["V0minimim=",V0minimim," rhominimum= ",rhominimum," Numinimum=",numinimum]];
If[printflag==1 || MemberQ[printflag,1] ,Print["VSminimale=",V0minimim," VarVSminimale=",numinimum^2 V0minimim," CoVarSVSminimale=",rhominimum V0minimim numinimum]];
{VS,VarVSIncrementale,CoVarSVSIncrementale}=AlphaDigitaleObservable1iz[S1,Si,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi];
If[printflag==1 || MemberQ[printflag,1] ,Print["VSBlack=",VS," VarVSIncrementale=",VarVSIncrementale," CoVarSVSIncrementale=",CoVarSVSIncrementale]];
VarVSTotal=VarVSIncrementale+numinimum^2 V0minimim;
CoVarSVSTotal=CoVarSVSIncrementale+rhominimum V0minimim numinimum;
If[printflag==1 || MemberQ[printflag,1] ,Print["VSTotal=",V0minimim," VarVSTotal=",VarVSTotal," CoVarSVSTotal= ",CoVarSVSTotal]];
\[Rho]projet\[EAcute]=CoVarSVSTotal/Sqrt[V0minimim VarVSTotal];\[Nu]projet\[EAcute]=Sqrt[VarVSTotal/V0minimim];V0projet\[EAcute]=V0minimim;
forward=S1-Si;
If[printflag==1 || MemberQ[printflag,1] ,Print["Normal Heston Parameters=",{{"S0",forward},{"V0",V0projet\[EAcute]},{"\[Rho]",\[Rho]projet\[EAcute]},{"\[Nu]",\[Nu]projet\[EAcute]},
{"standard dev equi.",Sqrt[VS]},{"\[Nu] normalized",\[Nu]projet\[EAcute]/Sqrt[VS]}} //MatrixForm]];
shiftL=0.0001;
CompoundK=IntercalePrice[K-shiftL,K+shiftL];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],V0projet\[EAcute],S1-Si,CompoundK,T,nbsteps,scale,microratio,0][[1]];
If[printflag==1 || MemberQ[printflag,1] ,Print["spreadoption prices=",prices]];
digitaleprices=Table[(prices[[2i-1]]-prices[[2i]])/(2shiftL),{i,1,Length[K]}];
If[printflag==1 || MemberQ[printflag,1] ,Print["digitale prices=",digitaleprices]];
digitaleprices
]


(* ::Input::Initialization:: *)
SmileAlphaDigitaleU1[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_,T_,LimitGindinkin_,printflag_,bilogtohestonflag_]:=
Module[{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]},
{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]}=ComputeEquivalentBilogFromAlpha[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,T];
Print["equivalent\[Sigma]1",equivalent\[Sigma]1," equivalent\[Sigma]i",equivalent\[Sigma]i," equivalent\[Rho]",equivalent\[Rho]];
SmileAlphaDigitale[S1  Exp[equivalent\[Sigma]1^2 T],Si Exp[equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T], \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,LT,\[Lambda],K,T,LimitGindinkin,printflag,bilogtohestonflag]
]


(* ::Input::Initialization:: *)
SmileAlphaDigitaleUi[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_,T_,LimitGindinkin_,printflag_,bilogtohestonflag_]:=
Module[{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]},
{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]}=ComputeEquivalentBilogFromAlpha[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,T];
Print["equivalent\[Sigma]1",equivalent\[Sigma]1," equivalent\[Sigma]i",equivalent\[Sigma]i," equivalent\[Rho]",equivalent\[Rho]];
SmileAlphaDigitale[S1   Exp[equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T],Si Exp[equivalent\[Sigma]i^2 T], \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,LT,\[Lambda],K,T,LimitGindinkin,printflag,bilogtohestonflag]
]


(* ::Input::Initialization:: *)
AlphaDigitalDeltaRatios[S1_,S2_,\[Sigma]1_,\[Sigma]2_,\[Rho]_,Vb_,rhob_,nub_,VbS1_,rhobS1_,nubS1_,VbS2_,rhobS2_,nubS2_,\[Lambda]_,L_,T_,nbsteps_,scale_,microratio_,flag_]:=Module[{S0=S1-S2,KList={S1-S2},der,derK,derKS1,derKS2,dermoinsKS1,dermoinsKS2,nuratioS1,nuratioS2,rhoratioS1,rhoratioS2},
der=DerivativeHestonNormalCall[rhob,\[Lambda],L,nub,Vb,S1-S2,{S1-S2},T,nbsteps,scale,microratio,flag];
derK=DerKDerivativeHestonNormalCall[rhob,\[Lambda],L,nub,Vb,S1-S2,{S1-S2},T,nbsteps,scale,microratio,flag];
derKS1=DerKDerivativeHestonNormalCall[rhobS1,\[Lambda],L,nubS1,VbS1,S1 E^(\[Sigma]1^2 T)-S2 E^(\[Rho] \[Sigma]1 \[Sigma]2 T),{S1-S2},T,nbsteps,scale,microratio,flag];
derKS2=DerKDerivativeHestonNormalCall[rhobS2,\[Lambda],L,nubS2,VbS2,S1 E^(\[Rho] \[Sigma]1 \[Sigma]2 T)-S2 E^(\[Sigma]2^2 T),{S1-S2},T,nbsteps,scale,microratio,flag];
Print["der=",der," derK=",derK," derKS1=",derKS1," derKS2=",derKS2];
dermoinsKS1=DerKDerivativeHestonNormalCall[-rhobS1,\[Lambda],L,nubS1,VbS1,S1 E^(\[Sigma]1^2 T)-S2 E^(\[Rho] \[Sigma]1 \[Sigma]2 T),{-S1+S2},T,nbsteps,scale,microratio,flag];
dermoinsKS2=DerKDerivativeHestonNormalCall[-rhobS2,\[Lambda],L,nubS2,VbS2,S1 E^(\[Rho] \[Sigma]1 \[Sigma]2 T)-S2 E^(\[Sigma]2^2 T),{-S1+S2},T,nbsteps,scale,microratio,flag];
Print["dermoinsKS1=",dermoinsKS1,"  dermoinsKS2=",dermoinsKS2];
rhoratioS1=(der[[3,1]]+(S1-S2) derK[[3,1]])/(derKS1[[3,1]]+dermoinsKS2[[3,1]]);
nuratioS1=(der[[4,1]]+(S1-S2) derK[[4,1]])/(derKS1[[4,1]]+dermoinsKS2[[4,1]]);
rhoratioS2=(der[[3,1]]+(S1-S2) derK[[3,1]])/(dermoinsKS1[[3,1]]+derKS2[[3,1]]);
nuratioS2=(der[[4,1]]+(S1-S2) derK[[4,1]])/(dermoinsKS1[[4,1]]+derKS2[[4,1]]);
{{rhoratioS1,nuratioS1},{rhoratioS2,nuratioS2}}
]


(* ::Input::Initialization:: *)
SmileAlphaDigitalesArbitrageFree[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_,T_,printflag_]:=
Module[{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],\[Rho]projet\[EAcute],\[Nu]projet\[EAcute],VarVSTotal,CoVarSVSTotal,VarVSIncrementale,CoVarSVSIncrementale,VS,Vb,rhob,nub,smoothFactor=10,nbsteps=120,scale=10,microratio=75,shiftL=0.0001,
price,digitaleprice,tryfunc,Kc,VbS1,V0x,CompoundK,prices,digitaleprices,S1prices,S1digitaleprices,Siprices,Sidigitaleprices,spreadoptions},
Kc=S1-Si;
{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]}=ComputeEquivalentBilogFromAlpha[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,T];
Print["equivalent\[Sigma]1",equivalent\[Sigma]1," equivalent\[Sigma]i",equivalent\[Sigma]i," equivalent\[Rho]",equivalent\[Rho]];
{VS,VarVSIncrementale,CoVarSVSIncrementale}=AlphaDigitaleObservable1iz[S1,Si,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi];
If[printflag==1 || MemberQ[printflag,1] ,Print["{VS,VarVSIncrementale,CoVarSVSIncrementale}=",{VS,VarVSIncrementale,CoVarSVSIncrementale}]];
{Vb,rhob,nub}=HestonFromBilogPackaged[S1,Si,equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],T,\[Lambda],LT,smoothFactor];
If[printflag==1 || MemberQ[printflag,1] ,Print["{Vb,rhob,nub}=",{Vb,rhob,nub}]];
VarVSTotal=nub^2 Vb+VarVSIncrementale;
CoVarSVSTotal=rhob Vb nub+CoVarSVSIncrementale;
\[Rho]projet\[EAcute]=CoVarSVSTotal/Sqrt[Vb VarVSTotal];\[Nu]projet\[EAcute]=Sqrt[VarVSTotal/Vb];
tryfunc=Function[{V0},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
price=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc},T,nbsteps,scale,microratio,0][[1,1]];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice=-(prices[[2]]-prices[[1]])/(2shiftL);
VbS1=V0x /. FindRoot[tryfunc[V0x]==price+Kc  digitaleprice+Si,{V0x,Vb,Vb/2,4Vb}];
If[printflag==1 || MemberQ[printflag,1] ,
Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
Print["VbS1=",VbS1];
Print["spreadoption =",price];
Print["digitaleprice=",digitaleprice];
Print["Kc=",Kc];
Print["digitaleS1=",digitalepriceS1];
Print["digitaleSi=",1-ByDualitydigitalepriceSi];
Print["digitaleS1 paying float=",S1 digitalepriceS1];
Print["digitaleSi paying float=",Si(1-ByDualitydigitalepriceSi)];
Print["S1 digitalepriceS1-Si (1-ByDualitydigitalepriceSi)-Kc  digitaleprice=",S1 digitalepriceS1-Si (1-ByDualitydigitalepriceSi)-Kc  digitaleprice];
Print["marge d'arbitrage =",price+Kc  digitaleprice+Si-tryfunc[VbS1]];
Print["\[Rho]projet\[EAcute]=",\[Rho]projet\[EAcute]," forward=",(S1  Exp[equivalent\[Sigma]1^2 T]-Si Exp[equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T])," \[Nu] standardize=",\[Nu]projet\[EAcute]/Sqrt[VbS1]]
]];
spreadoptions=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,K,T,nbsteps,scale,microratio,0][[1]];
CompoundK=IntercalePrice[K-shiftL,K+shiftL];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,CompoundK,T,nbsteps,scale,microratio,0][[1]];
digitaleprices=Table[(prices[[2i-1]]-prices[[2i]])/(2shiftL),{i,1,Length[K]}];
S1prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,S1  E^(equivalent\[Sigma]1^2 T) -Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T) ,CompoundK,T,nbsteps,scale,microratio,0][[1]];
S1digitaleprices=Table[(S1prices[[2i-1]]-S1prices[[2i]])/(2shiftL),{i,1,Length[K]}];
CompoundK=IntercalePrice[-K-shiftL,-K+shiftL];
Siprices=DerivativeHestonNormalCall[-\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,CompoundK,T,nbsteps,scale,microratio,0][[1]];
Sidigitaleprices=1-Table[(Siprices[[2i-1]]-Siprices[[2i]])/(2shiftL),{i,1,Length[K]}];
If[printflag==1 || MemberQ[printflag,1] ,
Print["digitale prices=",digitaleprices];Print["digitale paying Strike=",K digitaleprices];
Print["digitale prices(for S1 dig.)=",S1digitaleprices];Print["digitale (for S1 dig.) paying float=",S1 S1digitaleprices];
Print["digitale prices(for Si dig.)=",Sidigitaleprices];Print["digitale (for Si dig.) paying float=",Si Sidigitaleprices]];
{spreadoptions,digitaleprices,S1digitaleprices,Sidigitaleprices}
]


(* ::Input::Initialization:: *)
SmileAlphaDigitalesArbitrageFree2[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_,T_,printflag_,otherstrike_]:=
Module[{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],\[Rho]projet\[EAcute],\[Nu]projet\[EAcute],VarVSTotal,CoVarSVSTotal,VarVSIncrementale,CoVarSVSIncrementale,VS,Vb,rhob,nub,smoothFactor=10,nbsteps=120,scale=10,microratio=75,shiftL=0.0001,
price,digitaleprice,tryfunc,Kc,VbS1,V0x,CompoundK,prices,digitaleprices,S1prices,S1digitaleprices,Siprices,Sidigitaleprices,spreadoptions,
Kc2,tryfunc1,tryfunc2,price2,digitaleprice2,prices2,digitaleprices2,rhox,rhobS1,ss},
Kc=S1-Si;Kc2=otherstrike;
{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]}=ComputeEquivalentBilogFromAlpha[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,T];
Print["equivalent\[Sigma]1",equivalent\[Sigma]1," equivalent\[Sigma]i",equivalent\[Sigma]i," equivalent\[Rho]",equivalent\[Rho]];
{VS,VarVSIncrementale,CoVarSVSIncrementale}=AlphaDigitaleObservable1iz[S1,Si,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi];
If[printflag==1 || MemberQ[printflag,1] ,Print["{VS,VarVSIncrementale,CoVarSVSIncrementale}=",{VS,VarVSIncrementale,CoVarSVSIncrementale}]];
{Vb,rhob,nub}=HestonFromBilogPackaged[S1,Si,equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],T,\[Lambda],LT,smoothFactor];
If[printflag==1 || MemberQ[printflag,1] ,Print["{Vb,rhob,nub}=",{Vb,rhob,nub}]];
VarVSTotal=nub^2 Vb+VarVSIncrementale;
CoVarSVSTotal=rhob Vb nub+CoVarSVSIncrementale;
\[Rho]projet\[EAcute]=CoVarSVSTotal/Sqrt[Vb VarVSTotal];\[Nu]projet\[EAcute]=Sqrt[VarVSTotal/Vb];
tryfunc1=Function[{V0,rho},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[rho,\[Lambda],LT,\[Nu]projet\[EAcute],V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rho,\[Lambda],LT,\[Nu]projet\[EAcute],V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
tryfunc2=Function[{V0,rho},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[rho,\[Lambda],LT,\[Nu]projet\[EAcute],V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc2-shiftL,Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rho,\[Lambda],LT,\[Nu]projet\[EAcute],V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc2-shiftL,-Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
price=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc},T,nbsteps,scale,microratio,0][[1,1]];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice=-(prices[[2]]-prices[[1]])/(2shiftL);
price2=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc2},T,nbsteps,scale,microratio,0][[1,1]];
prices2=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc2-shiftL,Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice2=-(prices2[[2]]-prices2[[1]])/(2shiftL);
ss= FindRoot[{tryfunc1[V0x,rhox]==price+Kc  digitaleprice+Si,tryfunc2[V0x,rhox]==price2+Kc2  digitaleprice2+Si},{V0x,Vb,Vb/2,4Vb},{rhox,\[Rho]projet\[EAcute],-0.9,0.9}];
VbS1=V0x /.ss;
rhobS1=rhox /.ss;
If[printflag==1 || MemberQ[printflag,1] ,
Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi,pricesS1a,digitalepriceS1a,ByDualitypricesSia,ByDualitydigitalepriceSia},pricesS1=DerivativeHestonNormalCall[rhobS1,\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rhobS1,\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
pricesS1a=DerivativeHestonNormalCall[rhobS1,\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc2-shiftL,Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1a=-(pricesS1a[[2]]-pricesS1a[[1]])/(2shiftL);
ByDualitypricesSia=DerivativeHestonNormalCall[-rhobS1,\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc2-shiftL,-Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSia=-(ByDualitypricesSia[[2]]-ByDualitypricesSia[[1]])/(2shiftL);
Print["VbS1=",VbS1];Print["rhobS1=",rhobS1];
Print["spreadoption 1=",price];
Print["digitaleprice 1=",digitaleprice];
Print["Kc1 =",Kc];
Print["digitaleS1=",digitalepriceS1];
Print["digitaleSi=",1-ByDualitydigitalepriceSi];
Print["digitaleS1 paying float=",S1 digitalepriceS1];
Print["digitaleSi paying float=",Si(1-ByDualitydigitalepriceSi)];
Print["S1 digitalepriceS1-Si (1-ByDualitydigitalepriceSi)-Kc  digitaleprice=",S1 digitalepriceS1-Si (1-ByDualitydigitalepriceSi)-Kc  digitaleprice];
Print["marge d'arbitrage 1 =",price+Kc  digitaleprice+Si-tryfunc1[VbS1,rhobS1]];
Print["spreadoption 2=",price2];
Print["digitaleprice 2=",digitaleprice2];
Print["Kc2 =",Kc2];
Print["digitaleS1=",digitalepriceS1a];
Print["digitaleSi=",1-ByDualitydigitalepriceSia];
Print["digitaleS1 paying float=",S1 digitalepriceS1a];
Print["digitaleSi paying float=",Si(1-ByDualitydigitalepriceSia)];
Print["S1 digitalepriceS1-Si (1-ByDualitydigitalepriceSi)-Kc2  digitaleprice=",S1 digitalepriceS1a-Si (1-ByDualitydigitalepriceSia)-Kc  digitaleprice2];
Print["marge d'arbitrage 2 =",price2+Kc2  digitaleprice2+Si-tryfunc2[VbS1,rhobS1]];
]];
spreadoptions=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,K,T,nbsteps,scale,microratio,0][[1]];
CompoundK=IntercalePrice[K-shiftL,K+shiftL];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,CompoundK,T,nbsteps,scale,microratio,0][[1]];
digitaleprices=Table[(prices[[2i-1]]-prices[[2i]])/(2shiftL),{i,1,Length[K]}];
S1prices=DerivativeHestonNormalCall[rhobS1,\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,S1  E^(equivalent\[Sigma]1^2 T) -Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T) ,CompoundK,T,nbsteps,scale,microratio,0][[1]];
S1digitaleprices=Table[(S1prices[[2i-1]]-S1prices[[2i]])/(2shiftL),{i,1,Length[K]}];
CompoundK=IntercalePrice[-K-shiftL,-K+shiftL];
Siprices=DerivativeHestonNormalCall[-rhobS1,\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,CompoundK,T,nbsteps,scale,microratio,0][[1]];
Sidigitaleprices=1-Table[(Siprices[[2i-1]]-Siprices[[2i]])/(2shiftL),{i,1,Length[K]}];
If[printflag==1 || MemberQ[printflag,1] ,
Print["digitale prices=",digitaleprices];
Print["digitale prices(for S1 dig.)=",S1digitaleprices];
Print["digitale prices(for Si dig.)=",Sidigitaleprices];];
{spreadoptions,digitaleprices,S1digitaleprices,Sidigitaleprices}
]


(* ::Input::Initialization:: *)
SmileAlphaDigitalesArbitrageFree3[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_,T_,printflag_,otherstrike_,otherstrike2_]:=
Module[{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],\[Rho]projet\[EAcute],\[Nu]projet\[EAcute],VarVSTotal,CoVarSVSTotal,VarVSIncrementale,CoVarSVSIncrementale,VS,Vb,rhob,nub,smoothFactor=10,nbsteps=120,scale=10,microratio=75,shiftL=0.0001,
price,digitaleprice,tryfunc1,Kc,VbS1,V0x,CompoundK,prices,digitaleprices,S1prices,S1digitaleprices,Siprices,Sidigitaleprices,spreadoptions,
Kc2,tryfunc2,price2,digitaleprice2,prices2,digitaleprices2,rhox,rhobS1,Kc3,tryfunc3,price3,digitaleprice3,prices3,digitaleprices3,nux,nubS1},
Kc=S1-Si;Kc2=otherstrike;Kc3=otherstrike2;
{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]}=ComputeEquivalentBilogFromAlpha[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,T];
Print["equivalent\[Sigma]1",equivalent\[Sigma]1," equivalent\[Sigma]i",equivalent\[Sigma]i," equivalent\[Rho]",equivalent\[Rho]];
{VS,VarVSIncrementale,CoVarSVSIncrementale}=AlphaDigitaleObservable1iz[S1,Si,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi];
If[printflag==1 || MemberQ[printflag,1] ,Print["{VS,VarVSIncrementale,CoVarSVSIncrementale}=",{VS,VarVSIncrementale,CoVarSVSIncrementale}]];
{Vb,rhob,nub}=HestonFromBilogPackaged[S1,Si,equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],T,\[Lambda],LT,smoothFactor];
If[printflag==1 || MemberQ[printflag,1] ,Print["{Vb,rhob,nub}=",{Vb,rhob,nub}]];
VarVSTotal=nub^2 Vb+VarVSIncrementale;
CoVarSVSTotal=rhob Vb nub+CoVarSVSIncrementale;
\[Rho]projet\[EAcute]=CoVarSVSTotal/Sqrt[Vb VarVSTotal];\[Nu]projet\[EAcute]=Sqrt[VarVSTotal/Vb];
tryfunc1=Function[{V0,rho,nu},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[rho,\[Lambda],LT,nu,V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rho,\[Lambda],LT,nu,V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
tryfunc2=Function[{V0,rho,nu},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[rho,\[Lambda],LT,nu,V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc2-shiftL,Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rho,\[Lambda],LT,nu,V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc2-shiftL,-Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
tryfunc3=Function[{V0,rho,nu},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[rho,\[Lambda],LT,nu,V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc3-shiftL,Kc3+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rho,\[Lambda],LT,nu,V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc3-shiftL,-Kc3+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
price=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc},T,nbsteps,scale,microratio,0][[1,1]];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice=-(prices[[2]]-prices[[1]])/(2shiftL);
price2=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc2},T,nbsteps,scale,microratio,0][[1,1]];
prices2=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc2-shiftL,Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice2=-(prices2[[2]]-prices2[[1]])/(2shiftL);
price3=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc3},T,nbsteps,scale,microratio,0][[1,1]];
prices3=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc3-shiftL,Kc3+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice3=-(prices3[[2]]-prices3[[1]])/(2shiftL);
ss= FindRoot[{
tryfunc1[V0x,rhox,nux]==price+Kc  digitaleprice+Si,
tryfunc2[V0x,rhox,nux]==price2+Kc2  digitaleprice2+Si,
tryfunc3[V0x,rhox,nux]==price3+Kc3  digitaleprice3+Si},{V0x,Vb,Vb/2,4Vb},{rhox,\[Rho]projet\[EAcute],-0.9,0.9},{nux,\[Nu]projet\[EAcute],\[Nu]projet\[EAcute]/4,4 \[Nu]projet\[EAcute]}];
VbS1=V0x /.ss;
rhobS1=rhox /.ss;
nubS1=nux /.ss;
If[printflag==1 || MemberQ[printflag,1] ,
Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi,pricesS1a,digitalepriceS1a,ByDualitypricesSia,ByDualitydigitalepriceSia,
pricesS1b,digitalepriceS1b,ByDualitypricesSib,ByDualitydigitalepriceSib},

pricesS1=DerivativeHestonNormalCall[rhobS1,\[Lambda],LT,nubS1,VbS1,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rhobS1,\[Lambda],LT,nubS1,VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);

pricesS1a=DerivativeHestonNormalCall[rhobS1,\[Lambda],LT,nubS1,VbS1,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc2-shiftL,Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1a=-(pricesS1a[[2]]-pricesS1a[[1]])/(2shiftL);
ByDualitypricesSia=DerivativeHestonNormalCall[-rhobS1,\[Lambda],LT,nubS1,VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc2-shiftL,-Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSia=-(ByDualitypricesSia[[2]]-ByDualitypricesSia[[1]])/(2shiftL);

pricesS1b=DerivativeHestonNormalCall[rhobS1,\[Lambda],LT,nubS1,VbS1,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc3-shiftL,Kc3+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1b=-(pricesS1b[[2]]-pricesS1b[[1]])/(2shiftL);
ByDualitypricesSib=DerivativeHestonNormalCall[-rhobS1,\[Lambda],LT,nubS1,VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc3-shiftL,-Kc3+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSib=-(ByDualitypricesSib[[2]]-ByDualitypricesSib[[1]])/(2shiftL);
Print["resultat du solving:",ss];
Print["VbS1=",VbS1];Print["rhobS1=",rhobS1];Print["nubS1=",nubS1];
Print["spreadoption 1=",price];
Print["digitaleprice 1=",digitaleprice];
Print["Kc1 =",Kc];
Print["digitaleS1=",digitalepriceS1];
Print["digitaleSi=",1-ByDualitydigitalepriceSi];
Print["digitaleS1 paying float=",S1 digitalepriceS1];
Print["digitaleSi paying float=",Si(1-ByDualitydigitalepriceSi)];
Print["S1 digitalepriceS1-Si (1-ByDualitydigitalepriceSi)-Kc  digitaleprice=",S1 digitalepriceS1-Si (1-ByDualitydigitalepriceSi)-Kc  digitaleprice];
Print["marge d'arbitrage 1 =",price+Kc  digitaleprice+Si-tryfunc1[VbS1,rhobS1,nubS1]];
Print["spreadoption 2=",price2];
Print["digitaleprice 2=",digitaleprice2];
Print["Kc2 =",Kc2];
Print["digitaleS1=",digitalepriceS1a];
Print["digitaleSi=",1-ByDualitydigitalepriceSia];
Print["digitaleS1 paying float=",S1 digitalepriceS1a];
Print["digitaleSi paying float=",Si(1-ByDualitydigitalepriceSia)];
Print["S1 digitalepriceS1-Si (1-ByDualitydigitalepriceSi)-Kc2  digitaleprice=",S1 digitalepriceS1a-Si (1-ByDualitydigitalepriceSia)-Kc  digitaleprice2];
Print["marge d'arbitrage 2 =",price2+Kc2  digitaleprice2+Si-tryfunc2[VbS1,rhobS1,nubS1]];
Print["spreadoption 3=",price3];
Print["digitaleprice 3=",digitaleprice3];
Print["Kc3 =",Kc3];
Print["digitaleS3=",digitalepriceS1b];
Print["digitaleSi=",1-ByDualitydigitalepriceSib];
Print["digitaleS1 paying float=",S1 digitalepriceS1b];
Print["digitaleSi paying float=",Si(1-ByDualitydigitalepriceSib)];
Print["S1 digitalepriceS1-Si (1-ByDualitydigitalepriceSi)-Kc2  digitaleprice=",S1 digitalepriceS1b-Si (1-ByDualitydigitalepriceSib)-Kc2  digitaleprice3];
Print["marge d'arbitrage 2 =",price3+Kc3  digitaleprice3+Si-tryfunc3[VbS1,rhobS1,nubS1]];
]];
spreadoptions=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,K,T,nbsteps,scale,microratio,0][[1]];
CompoundK=IntercalePrice[K-shiftL,K+shiftL];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,CompoundK,T,nbsteps,scale,microratio,0][[1]];
digitaleprices=Table[(prices[[2i-1]]-prices[[2i]])/(2shiftL),{i,1,Length[K]}];
S1prices=DerivativeHestonNormalCall[rhobS1,\[Lambda],LT,nubS1,VbS1,S1  E^(equivalent\[Sigma]1^2 T) -Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T) ,CompoundK,T,nbsteps,scale,microratio,0][[1]];
S1digitaleprices=Table[(S1prices[[2i-1]]-S1prices[[2i]])/(2shiftL),{i,1,Length[K]}];
CompoundK=IntercalePrice[-K-shiftL,-K+shiftL];
Siprices=DerivativeHestonNormalCall[-rhobS1,\[Lambda],LT,nubS1,VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,CompoundK,T,nbsteps,scale,microratio,0][[1]];
Sidigitaleprices=1-Table[(Siprices[[2i-1]]-Siprices[[2i]])/(2shiftL),{i,1,Length[K]}];
If[printflag==1 || MemberQ[printflag,1] ,
Print["digitale prices=",digitaleprices];
Print["digitale prices(for S1 dig.)=",S1digitaleprices];
Print["digitale prices(for Si dig.)=",Sidigitaleprices];];
{spreadoptions,digitaleprices,S1digitaleprices,Sidigitaleprices}
]


(* ::Input::Initialization:: *)
SmileAlphaDigitalesArbitrageFree3[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_,T_,printflag_,otherstrike_,otherstrike2_]:=
Module[{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],\[Rho]projet\[EAcute],\[Nu]projet\[EAcute],VarVSTotal,CoVarSVSTotal,VarVSIncrementale,CoVarSVSIncrementale,VS,Vb,rhob,nub,smoothFactor=10,nbsteps=120,scale=10,microratio=75,shiftL=0.0001,
price,digitaleprice,tryfunc1,Kc,VbS1,V0x,CompoundK,prices,digitaleprices,S1prices,S1digitaleprices,Siprices,Sidigitaleprices,spreadoptions,
Kc2,tryfunc2,price2,digitaleprice2,prices2,digitaleprices2,rhox,rhobS1,Kc3,tryfunc3,price3,digitaleprice3,prices3,digitaleprices3,nux,nubS1},
Kc=S1-Si;Kc2=otherstrike;Kc3=otherstrike2;
{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]}=ComputeEquivalentBilogFromAlpha[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,T];
Print["equivalent\[Sigma]1",equivalent\[Sigma]1," equivalent\[Sigma]i",equivalent\[Sigma]i," equivalent\[Rho]",equivalent\[Rho]];
{VS,VarVSIncrementale,CoVarSVSIncrementale}=AlphaDigitaleObservable1iz[S1,Si,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi];
If[printflag==1 || MemberQ[printflag,1] ,Print["{VS,VarVSIncrementale,CoVarSVSIncrementale}=",{VS,VarVSIncrementale,CoVarSVSIncrementale}]];
{Vb,rhob,nub}=HestonFromBilogPackaged[S1,Si,equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],T,\[Lambda],LT,smoothFactor];
If[printflag==1 || MemberQ[printflag,1] ,Print["{Vb,rhob,nub}=",{Vb,rhob,nub}]];
VarVSTotal=nub^2 Vb+VarVSIncrementale;
CoVarSVSTotal=rhob Vb nub+CoVarSVSIncrementale;
\[Rho]projet\[EAcute]=CoVarSVSTotal/Sqrt[Vb VarVSTotal];\[Nu]projet\[EAcute]=Sqrt[VarVSTotal/Vb];
tryfunc1=Function[{V0,rho,nu},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[rho,\[Lambda],LT,nu,V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rho,\[Lambda],LT,nu,V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
tryfunc2=Function[{V0,rho,nu},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[rho,\[Lambda],LT,nu,V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc2-shiftL,Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rho,\[Lambda],LT,nu,V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc2-shiftL,-Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
tryfunc3=Function[{V0,rho,nu},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[rho,\[Lambda],LT,nu,V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc3-shiftL,Kc3+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rho,\[Lambda],LT,nu,V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc3-shiftL,-Kc3+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
price=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc},T,nbsteps,scale,microratio,0][[1,1]];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice=-(prices[[2]]-prices[[1]])/(2shiftL);
price2=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc2},T,nbsteps,scale,microratio,0][[1,1]];
prices2=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc2-shiftL,Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice2=-(prices2[[2]]-prices2[[1]])/(2shiftL);
price3=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc3},T,nbsteps,scale,microratio,0][[1,1]];
prices3=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc3-shiftL,Kc3+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice3=-(prices3[[2]]-prices3[[1]])/(2shiftL);
ss= FindRoot[{tryfunc1[V0x,rhox,nux]==price+Kc  digitaleprice+Si,
tryfunc2[V0x,rhox,nux]==price2+Kc2  digitaleprice2+Si,
tryfunc3[V0x,rhox,nux]==price3+Kc3  digitaleprice3+Si},
{V0x,Vb,Vb/2,4Vb},{rhox,\[Rho]projet\[EAcute],-0.9,0.9},{nux,\[Nu]projet\[EAcute],\[Nu]projet\[EAcute]/4,4 \[Nu]projet\[EAcute]}];
VbS1=V0x /.ss;
rhobS1=rhox /.ss;
nubS1=nux /.ss;
Print["contrainte=",{V0x,Vb,Vb/2,4Vb},{rhox,\[Rho]projet\[EAcute],-0.9,0.9},{nux,\[Nu]projet\[EAcute],\[Nu]projet\[EAcute]/4,4 \[Nu]projet\[EAcute]}];
{{VbS1,rhobS1,nubS1},
{tryfunc1[VbS1,rhobS1,nubS1],price+Kc  digitaleprice+Si},
{tryfunc2[VbS1,rhobS1,nubS1],price2+Kc2  digitaleprice2+Si},
{tryfunc3[VbS1,rhobS1,nubS1],price3+Kc3  digitaleprice3+Si}}
]


(* ::Input::Initialization:: *)
SmileAlphaDigitalesArbitrageFree3[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_,T_,printflag_,otherstrike_,otherstrike2_]:=
Module[{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],\[Rho]projet\[EAcute],\[Nu]projet\[EAcute],VarVSTotal,CoVarSVSTotal,VarVSIncrementale,CoVarSVSIncrementale,VS,Vb,rhob,nub,smoothFactor=10,nbsteps=120,scale=10,microratio=75,shiftL=0.0001,
price,digitaleprice,tryfunc1,Kc,VbS1,V0x,CompoundK,prices,digitaleprices,S1prices,S1digitaleprices,Siprices,Sidigitaleprices,spreadoptions,
Kc2,tryfunc2,price2,digitaleprice2,prices2,digitaleprices2,rhox,rhobS1,Kc3,tryfunc3,price3,digitaleprice3,prices3,digitaleprices3,nux,nubS1,ss},
Kc=S1-Si;Kc2=otherstrike;Kc3=otherstrike2;
{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]}=ComputeEquivalentBilogFromAlpha[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,T];
Print["equivalent\[Sigma]1",equivalent\[Sigma]1," equivalent\[Sigma]i",equivalent\[Sigma]i," equivalent\[Rho]",equivalent\[Rho]];
{VS,VarVSIncrementale,CoVarSVSIncrementale}=AlphaDigitaleObservable1iz[S1,Si,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi];
If[printflag==1 || MemberQ[printflag,1] ,Print["{VS,VarVSIncrementale,CoVarSVSIncrementale}=",{VS,VarVSIncrementale,CoVarSVSIncrementale}]];
{Vb,rhob,nub}=HestonFromBilogPackaged[S1,Si,equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],T,\[Lambda],LT,smoothFactor];
If[printflag==1 || MemberQ[printflag,1] ,Print["{Vb,rhob,nub}=",{Vb,rhob,nub}]];
VarVSTotal=nub^2 Vb+VarVSIncrementale;
CoVarSVSTotal=rhob Vb nub+CoVarSVSIncrementale;
\[Rho]projet\[EAcute]=CoVarSVSTotal/Sqrt[Vb VarVSTotal];\[Nu]projet\[EAcute]=Sqrt[VarVSTotal/Vb];
tryfunc1=Function[{V0,rho,nu},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[rho,\[Lambda],LT,nu,V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rho,\[Lambda],LT,nu,V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
tryfunc2=Function[{V0,rho,nu},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[rho,\[Lambda],LT,nu,V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc2-shiftL,Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rho,\[Lambda],LT,nu,V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc2-shiftL,-Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
tryfunc3=Function[{V0,rho,nu},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[rho,\[Lambda],LT,nu,V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc3-shiftL,Kc3+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-rho,\[Lambda],LT,nu,V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc3-shiftL,-Kc3+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
price=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc},T,nbsteps,scale,microratio,0][[1,1]];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice=-(prices[[2]]-prices[[1]])/(2shiftL);
price2=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc2},T,nbsteps,scale,microratio,0][[1,1]];
prices2=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc2-shiftL,Kc2+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice2=-(prices2[[2]]-prices2[[1]])/(2shiftL);
price3=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc3},T,nbsteps,scale,microratio,0][[1,1]];
prices3=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc3-shiftL,Kc3+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice3=-(prices3[[2]]-prices3[[1]])/(2shiftL);
ss= FindMinimum[(tryfunc1[V0x,rhox,nux]-price+Kc  digitaleprice+Si)^2+
(tryfunc2[V0x,rhox,nux]-price2+Kc2  digitaleprice2+Si)^2+
(tryfunc3[V0x,rhox,nux]-price3+Kc3  digitaleprice3+Si)^2,
{{V0x,Vb,Vb/2,8Vb},{rhox,\[Rho]projet\[EAcute],-0.9,0.9},{nux,\[Nu]projet\[EAcute],\[Nu]projet\[EAcute]/4,4 \[Nu]projet\[EAcute]}},Method->LevenbergMarquardt];
Print["ss=",ss];
VbS1=V0x /.ss[[2]];
rhobS1=rhox /.ss[[2]];
nubS1=nux /.ss[[2]];
Print["contrainte=",{V0x,Vb,Vb/2,4Vb},{rhox,\[Rho]projet\[EAcute],-0.9,0.9},{nux,\[Nu]projet\[EAcute],\[Nu]projet\[EAcute]/4,4 \[Nu]projet\[EAcute]}];
{{VbS1,rhobS1,nubS1},
{tryfunc1[VbS1,rhobS1,nubS1],price+Kc  digitaleprice+Si},
{tryfunc2[VbS1,rhobS1,nubS1],price2+Kc2  digitaleprice2+Si},
{tryfunc3[VbS1,rhobS1,nubS1],price3+Kc3  digitaleprice3+Si}}
]


(* ::Input::Initialization:: *)
SmileAlphaDigitaleU1ArbitrageFree[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_,T_,printflag_]:=
Module[{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],\[Rho]projet\[EAcute],\[Nu]projet\[EAcute],VarVSTotal,CoVarSVSTotal,VarVSIncrementale,CoVarSVSIncrementale,VS,Vb,rhob,nub,smoothFactor=10,nbsteps=120,scale=10,microratio=75,shiftL=0.0001,
price,prices,digitaleprice,tryfunc,Kc,VbS1,V0x,CompoundK,digitaleprices},
Kc=S1-Si;
{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]}=ComputeEquivalentBilogFromAlpha[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,T];
Print["equivalent\[Sigma]1",equivalent\[Sigma]1," equivalent\[Sigma]i",equivalent\[Sigma]i," equivalent\[Rho]",equivalent\[Rho]];
{VS,VarVSIncrementale,CoVarSVSIncrementale}=AlphaDigitaleObservable1iz[S1,Si,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi];
If[printflag==1 || MemberQ[printflag,1] ,Print["{VS,VarVSIncrementale,CoVarSVSIncrementale}=",{VS,VarVSIncrementale,CoVarSVSIncrementale}]];
{Vb,rhob,nub}=HestonFromBilogPackaged[S1,Si,equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],T,\[Lambda],LT,smoothFactor];
If[printflag==1 || MemberQ[printflag,1] ,Print["{Vb,rhob,nub}=",{Vb,rhob,nub}]];
VarVSTotal=nub^2 Vb+VarVSIncrementale;
CoVarSVSTotal=rhob Vb nub+CoVarSVSIncrementale;
\[Rho]projet\[EAcute]=CoVarSVSTotal/Sqrt[Vb VarVSTotal];\[Nu]projet\[EAcute]=Sqrt[VarVSTotal/Vb];
tryfunc=Function[{V0},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
Print["arg pour spreadoption=",{\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc},T,nbsteps,scale,microratio}];
price=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc},T,nbsteps,scale,microratio,0][[1,1]];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice=-(prices[[2]]-prices[[1]])/(2shiftL);
If[printflag==1 || MemberQ[printflag,1] ,Print["price=",price," digitaleprice=",digitaleprice]];
VbS1=V0x /. FindRoot[tryfunc[V0x]==price+Kc  digitaleprice+Si,{V0x,Vb,Vb/2,4Vb}];
If[printflag==1 || MemberQ[printflag,1] ,Print["VbS1=",VbS1];Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
Print["digitaleprice=",digitaleprice];
Print["Kc=",Kc];
Print["digitaleS1=",digitalepriceS1];
Print["digitaleSi=",1-ByDualitydigitalepriceSi];
Print["digitaleS1 paying float=",S1 digitalepriceS1];
Print["digitaleSi paying float=",Si(1-ByDualitydigitalepriceSi)];
Print["S1 digitalepriceS1-Si (1-ByDualitydigitalepriceSi)-Kc  digitaleprice=",S1 digitalepriceS1-Si (1-ByDualitydigitalepriceSi)-Kc  digitaleprice];
Print["spreadoption =",price];
];
Print["spreadoption=",price," digitaleprice=",digitaleprice," digitaleS1-dualdigitaleSi=",tryfunc[VbS1]];];
If[printflag==1 || MemberQ[printflag,1] ,Print["price+Kc  digitaleprice+Si =",price+Kc  digitaleprice+Si]];
If[printflag==1 || MemberQ[printflag,1] ,Print["marge d'arbitrage =",price+Kc  digitaleprice+Si-tryfunc[VbS1]]];
CompoundK=IntercalePrice[K-shiftL,K+shiftL];
Print["\[Rho]projet\[EAcute]=",\[Rho]projet\[EAcute]," forward=",(S1  Exp[equivalent\[Sigma]1^2 T]-Si Exp[equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T])," \[Nu] standardize=",\[Nu]projet\[EAcute]/Sqrt[VbS1]];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,S1  Exp[equivalent\[Sigma]1^2 T]-Si Exp[equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T],CompoundK,T,nbsteps,scale,microratio,0][[1]];
If[printflag==1 || MemberQ[printflag,1] ,Print["spreadoption prices=",prices]];
digitaleprices=Table[(prices[[2i-1]]-prices[[2i]])/(2shiftL),{i,1,Length[K]}];
If[printflag==1 || MemberQ[printflag,1] ,Print["digitale prices=",digitaleprices]];
If[printflag==1 || MemberQ[printflag,1] ,Print["digitale paying float=",S1 digitaleprices]];
digitaleprices
]


(* ::Input::Initialization:: *)
SmileAlphaDigitaleUiArbitrageFree[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,K_,T_,printflag_]:=
Module[{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],\[Rho]projet\[EAcute],\[Nu]projet\[EAcute],VarVSTotal,CoVarSVSTotal,VarVSIncrementale,CoVarSVSIncrementale,VS,Vb,rhob,nub,smoothFactor=10,nbsteps=120,scale=10,microratio=75,shiftL=0.0001,
price,prices,digitaleprice,tryfunc,Kc,VbS1,V0x,CompoundK,digitaleprices,ByDualitypricesSia,ByDualitydigitalepriceSia},
Kc=S1-Si;
{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]}=ComputeEquivalentBilogFromAlpha[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,T];
Print["equivalent\[Sigma]1",equivalent\[Sigma]1," equivalent\[Sigma]i",equivalent\[Sigma]i," equivalent\[Rho]",equivalent\[Rho]];
{VS,VarVSIncrementale,CoVarSVSIncrementale}=AlphaDigitaleObservable1iz[S1,Si,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi];
If[printflag==1 || MemberQ[printflag,1] ,Print["{VS,VarVSIncrementale,CoVarSVSIncrementale}=",{VS,VarVSIncrementale,CoVarSVSIncrementale}]];
{Vb,rhob,nub}=HestonFromBilogPackaged[S1,Si,equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],T,\[Lambda],LT,smoothFactor];
If[printflag==1 || MemberQ[printflag,1] ,Print["{Vb,rhob,nub}=",{Vb,rhob,nub}]];
VarVSTotal=nub^2 Vb+VarVSIncrementale;
CoVarSVSTotal=rhob Vb nub+CoVarSVSIncrementale;
\[Rho]projet\[EAcute]=CoVarSVSTotal/Sqrt[Vb VarVSTotal];\[Nu]projet\[EAcute]=Sqrt[VarVSTotal/Vb];
tryfunc=Function[{V0},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],V0,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
ByDualitypricesSi=DerivativeHestonNormalCall[-\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],V0,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
S1 digitalepriceS1+Si ByDualitydigitalepriceSi]];
price=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc},T,nbsteps,scale,microratio,0][[1,1]];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitaleprice=-(prices[[2]]-prices[[1]])/(2shiftL);
VbS1=V0x /. FindRoot[tryfunc[V0x]==price+Kc  digitaleprice+Si,{V0x,Vb,Vb/2,4Vb}];
If[printflag==1 || MemberQ[printflag,1] ,Print["VbS1=",VbS1];

Print["digitaleS1=",Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},pricesS1=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),{Kc-shiftL,Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=-(pricesS1[[2]]-pricesS1[[1]])/(2shiftL);
digitalepriceS1]];
Print["digitaleSi=",Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi},
ByDualitypricesSi=DerivativeHestonNormalCall[-\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,{-Kc-shiftL,-Kc+shiftL},T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=-(ByDualitypricesSi[[2]]-ByDualitypricesSi[[1]])/(2shiftL);
1-ByDualitydigitalepriceSi]];Print["spreadoption=",price," digitaleprice=",digitaleprice," digitaleS1-dualdigitaleSi=",tryfunc[VbS1]];];
If[printflag==1 || MemberQ[printflag,1] ,Print["price+Kc  digitaleprice+Si =",price+Kc  digitaleprice+Si]];
If[printflag==1 || MemberQ[printflag,1] ,Print["marge d'arbitrage =",price+Kc  digitaleprice+Si-tryfunc[VbS1]]];
CompoundK=IntercalePrice[-K-shiftL,-K+shiftL];
Print["CompoundK=",CompoundK];
Print["\[Rho]projet\[EAcute]=",\[Rho]projet\[EAcute]," forward=",(S1  Exp[equivalent\[Sigma]1^2 T]-Si Exp[equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T])," \[Nu] standardize=",\[Nu]projet\[EAcute]/Sqrt[VbS1]];

prices=DerivativeHestonNormalCall[-\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],VbS1,-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,CompoundK,T,nbsteps,scale,microratio,0][[1]];
If[printflag==1 || MemberQ[printflag,1] ,Print["spreadoption prices=",prices]];
digitaleprices=1-Table[(prices[[2i-1]]-prices[[2i]])/(2shiftL),{i,1,Length[K]}];
If[printflag==1 || MemberQ[printflag,1] ,Print["digitale prices=",digitaleprices]];
If[printflag==1 || MemberQ[printflag,1] ,Print["digitale paying float=",Si digitaleprices]];
digitaleprices
]


(* ::Input::Initialization:: *)
DigitaleNormalHestonFromBilogPackaged[S1_,Si_,\[Sigma]1_,\[Sigma]i_,Correl1i_,Vb_,\[Rho]projet\[EAcute]_,\[Nu]projet\[EAcute]_,T_,\[Lambda]_,LT_,strikes_,\[Lambda]smooth_,printflag_]:=
Module[{pricegoaltable,WeightList,nbsteps,scale,microratio,nbstrike,ss,\[Rho],\[Nu],InitialV0,CompoundKSuper,priceSuper,Superdigitale,Superspreadoption,Superalgoprices,
\[Rho]down=-0.9,\[Rho]up=0.9,\[Nu]down=0.000001,\[Nu]up,V0down,V0up,shiftL=0.0001,StandardizedNuMax=4,CompoundK,price,prices,digitaleprice},
If[printflag==1 || MemberQ[printflag,1] ,Print["-----------------inside DigitaleNormalHestonFromBilogPackaged"]];
InitialV0=S1^2 \[Sigma]1^2+Si^2 \[Sigma]i^2-2Correl1i S1 Si \[Sigma]1 \[Sigma]i;
V0down=InitialV0 0.95;V0up=10 InitialV0;\[Nu]up=StandardizedNuMax Sqrt[InitialV0];
If[printflag==1 || MemberQ[printflag,1] ,Print["InitialV0=",InitialV0," \[Nu]up=",\[Nu]up," Stdev(pour le calcul des strike)=",Sqrt[InitialV0 T]]];
If[printflag==1 || MemberQ[printflag,1] ,Print["strikes=",strikes]];
nbstrike=Length[strikes];
CompoundK=IntercalePrice[strikes-shiftL,strikes+shiftL];
If[printflag==1 || MemberQ[printflag,1] ,Print["CompoundK=",CompoundK]];
nbsteps=40;scale=8;microratio=5 T^(1/2);

CompoundKSuper=IntercalePrice[strikes-shiftL,strikes,strikes+shiftL];
priceSuper=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,CompoundKSuper,T,nbsteps,scale,microratio,0][[1]];
Print["S1-Si=",S1-Si,"  Vb=",Vb,"  \[Rho]projet\[EAcute]=",\[Rho]projet\[EAcute],"  \[Nu]projet\[EAcute]=",\[Nu]projet\[EAcute]," nbsteps=",nbsteps," scale=",scale," microratio=",microratio];
Print["CompoundKSuper strikes price=",CompoundKSuper];
Print["priceSuper spreadoption price=",priceSuper];
Superdigitale=Table[(priceSuper[[1+3i]]-priceSuper[[3+3i]])/(2 shiftL),{i,0,Length[strikes]-1}];
Superspreadoption=Table[priceSuper[[2+3i]],{i,0,Length[strikes]-1}];
Superalgoprices=Table[Superspreadoption[[i+1]]+strikes[[i+1]]Superdigitale[[i+1]]+Si ,{i,0,Length[strikes]-1}];
Print["Superdigitale  =",Superdigitale];
Print["Superspreadoption  =",Superspreadoption];
Print["Superalgoprices  =",Superalgoprices];

price=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,strikes,T,nbsteps,scale,microratio,0][[1]];
Print["spreadoption price=",price];
Print["arg Market price=",{\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,strikes,T,nbsteps,scale,microratio}];
prices=DerivativeHestonNormalCall[\[Rho]projet\[EAcute],\[Lambda],LT,\[Nu]projet\[EAcute],Vb,S1-Si,CompoundK,T,nbsteps,scale,microratio,0][[1]];
If[printflag==1 || MemberQ[printflag,1] ,Print["price=",price];Print["prices=",prices]];
digitaleprice=Table[(prices[[2i-1]]-prices[[2i]])/(2shiftL),{i,1,Length[strikes]}];
pricegoaltable=Table[price[[i]]+strikes[[i]]  digitaleprice[[i]]+Si,{i,1,nbstrike}];
If[printflag==1 || MemberQ[printflag,1] ,Print["pricegoaltable=",pricegoaltable]];
WeightList=Table[1,{i,1,nbstrike}];
ss=NormalHestonDigitaleS1SmileCalibratePackaged[strikes,pricegoaltable,WeightList,S1,Si,\[Sigma]1,\[Sigma]i,Correl1i,\[Lambda],LT,T,nbsteps,scale,microratio,InitialV0,StandardizedNuMax,\[Lambda]smooth,V0down,V0up,\[Rho]down,\[Rho]up,\[Nu]down,\[Nu]up,printflag];
If[printflag==1 || MemberQ[printflag,1] ,Print["optimisation results:",ss]];
{ControleVariable[ss[[2,1]],V0down,V0up,\[Lambda]smooth],ControleVariable[ss[[2,2]],\[Rho]down,\[Rho]up,\[Lambda]smooth],ControleVariable[ss[[2,3]],\[Nu]down,\[Nu]up,\[Lambda]smooth]}
]


(* ::Input::Initialization:: *)
NormalHestonDigitaleS1SmileCalibratePackaged[KList_,PriceList_,WeightList_,S1_,Si_,equivalent\[Sigma]1_,equivalent\[Sigma]i_,equivalent\[Rho]_,\[Lambda]_,LT_,T_,nbsteps_,scale_,microratio_,InitialV0_,StandardizedNuMax_,\[Lambda]smooth_,V0down_,V0up_,\[Rho]down_,\[Rho]up_,\[Nu]down_,\[Nu]up_,printflag_]:=Module[{func,gradfunc,V0,rho,nu,ss,NewWeightList,shiftL=0.0001,StartingV0,CompoundK,CompoundMinusK,func1,controlV0,controlnu},
If[printflag==1 || MemberQ[printflag,1] ,Print["---------------------inside NormalHestonDigitaleSmileCalibratePackaged"]];
NewWeightList=Table[WeightList[[i]]/NormalCallVega[S1-Si,KList[[i]],T,Sqrt[InitialV0]],{i,1,Length[WeightList]}];
CompoundK=IntercalePrice[KList-shiftL,KList+shiftL];
CompoundMinusK=IntercalePrice[-KList-shiftL,-KList+shiftL];
If[printflag==1 || MemberQ[printflag,1] ,Print["CompoundK=",CompoundK];Print["CompoundMinusK=",CompoundMinusK]];
func=Function[{V,\[Rho],\[Nu]},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi,ff},
pricesS1=DerivativeHestonNormalCall[
ControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth],\[Lambda],LT,
ControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth],
ControleVariable[V,V0down,V0up,\[Lambda]smooth],S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),CompoundK,T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=Table[(pricesS1[[2i-1]]-pricesS1[[2i]])/(2shiftL),{i,1,Length[KList]}];
ByDualitypricesSi=DerivativeHestonNormalCall[
-ControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth],\[Lambda],LT,
ControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth],
ControleVariable[V,V0down,V0up,\[Lambda]smooth],-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,CompoundMinusK,T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=Table[(ByDualitypricesSi[[2i-1]]-ByDualitypricesSi[[2i]])/(2shiftL),{i,1,Length[KList]}];
ff=S1 digitalepriceS1+Si ByDualitydigitalepriceSi;
Sum[NewWeightList[[i]](PriceList[[i]]-ff[[i]])^2,{i,1,Length[KList]}]]];
func1=Function[{V,\[Rho],\[Nu]},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi,ff},
pricesS1=DerivativeHestonNormalCall[
ControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth],\[Lambda],LT,
ControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth],
ControleVariable[V,V0down,V0up,\[Lambda]smooth],S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),CompoundK,T,nbsteps,scale,microratio,0][[1]];
digitalepriceS1=Table[(pricesS1[[2i-1]]-pricesS1[[2i]])/(2shiftL),{i,1,Length[KList]}];
ByDualitypricesSi=DerivativeHestonNormalCall[
-ControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth],\[Lambda],LT,
ControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth],
ControleVariable[V,V0down,V0up,\[Lambda]smooth],-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,CompoundMinusK,T,nbsteps,scale,microratio,0][[1]];
ByDualitydigitalepriceSi=Table[(ByDualitypricesSi[[2i-1]]-ByDualitypricesSi[[2i]])/(2shiftL),{i,1,Length[KList]}];
ff=S1 digitalepriceS1+Si ByDualitydigitalepriceSi;
Print["pricesS1=",pricesS1];
Print["{V,V0down,V0up,\[Lambda]smooth}=",{V,V0down,V0up,\[Lambda]smooth}];
Print["{\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth}=",{\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth}];
Print["{\[Nu],V0down,V0up,\[Lambda]smooth}=",{\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth}];
Print["ByDualitypricesSi=",ByDualitypricesSi];
Print["digitalepriceS1=",digitalepriceS1];
Print["ByDualitydigitalepriceSi=",ByDualitydigitalepriceSi];
Print["market prices=",ff];
Print["ecarts=",Table[PriceList[[i]]-ff[[i]],{i,1,Length[PriceList]}]];
Print["NewWeightList=",NewWeightList];
Do[
Print["****ByDualitypricesSi[[2i-1]]=",ByDualitypricesSi[[2i-1]]," ByDualitypricesSi[[2i]]=",ByDualitypricesSi[[2i]],"  Si=",Si," shiftL=",shiftL];
Print["pricesS1[[2i-1]]=",pricesS1[[2i-1]]," pricesS1[[2i]]=",pricesS1[[2i]],"  S1=",S1," S1 digitalepriceS1+Si ByDualitydigitalepriceSi=",ff[[i]]],{i,1,Length[KList]}];
Sum[NewWeightList[[i]](PriceList[[i]]-ff[[i]])^2,{i,1,Length[KList]}]]];
gradfunc=Function[{V,\[Rho],\[Nu]},Module[{pricesS1,digitalepriceS1,ByDualitypricesSi,ByDualitydigitalepriceSi,ff},
pricesS1=DerivativeHestonNormalCall[
ControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth],\[Lambda],LT,
ControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth],
ControleVariable[V,V0down,V0up,\[Lambda]smooth],S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T),CompoundK,T,nbsteps,scale,microratio];
digitalepriceS1={Table[(pricesS1[[1,2i-1]]-pricesS1[[1,2i]])/(2shiftL),{i,1,Length[KList]}],
Table[(pricesS1[[2,2i-1]]-pricesS1[[2,2i]])/(2shiftL),{i,1,Length[KList]}],
Table[(pricesS1[[3,2i-1]]-pricesS1[[3,2i]])/(2shiftL),{i,1,Length[KList]}],
Table[(pricesS1[[4,2i-1]]-pricesS1[[4,2i]])/(2shiftL),{i,1,Length[KList]}]};
ByDualitypricesSi=DerivativeHestonNormalCall[
-ControleVariable[\[Rho],\[Rho]down,\[Rho]up,\[Lambda]smooth],\[Lambda],LT,
ControleVariable[\[Nu],\[Nu]down,\[Nu]up,\[Lambda]smooth],
ControleVariable[V,V0down,V0up,\[Lambda]smooth],-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T)) ,CompoundMinusK,T,nbsteps,scale,microratio];
ByDualitydigitalepriceSi={Table[(ByDualitypricesSi[[1,2i-1]]-ByDualitypricesSi[[1,2i]])/(2shiftL),{i,1,Length[KList]}],
Table[(ByDualitypricesSi[[2,2i-1]]-ByDualitypricesSi[[2,2i]])/(2shiftL),{i,1,Length[KList]}],
Table[(ByDualitypricesSi[[3,2i-1]]-ByDualitypricesSi[[3,2i]])/(2shiftL),{i,1,Length[KList]}],
Table[(ByDualitypricesSi[[4,2i-1]]-ByDualitypricesSi[[4,2i]])/(2shiftL),{i,1,Length[KList]}]};
ff={Table[S1 digitalepriceS1[[1,i]]+Si ByDualitydigitalepriceSi[[1,i]],{i,1,Length[KList]}],
Table[S1 digitalepriceS1[[2,i]]+Si ByDualitydigitalepriceSi[[2,i]],{i,1,Length[KList]}],
Table[S1 digitalepriceS1[[3,i]]+Si ByDualitydigitalepriceSi[[3,i]],{i,1,Length[KList]}],
Table[S1 digitalepriceS1[[4,i]]+Si ByDualitydigitalepriceSi[[4,i]],{i,1,Length[KList]}]};
Sum[{
NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[2,i]],
NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[3,i]],
NewWeightList[[i]](PriceList[[i]]-ff[[1,i]])ff[[4,i]]},{i,1,Length[KList]}]]];
StartingV0=InitialV0 1.05;
controlV0 =2.6888*10^(-6);
controlnu =0.0000256076;

If[printflag==1 || MemberQ[printflag,1] ,
Print["func(",controlV0,",",0.0,",",controlnu,")=",func[controlV0,0,controlnu]];
Print["func1(",controlV0,",",0.0,",",controlnu,")=",func1[controlV0,0,controlnu]];
Print["S1=",S1," Si=",Si," equivalent\[Sigma]1=",equivalent\[Sigma]1," equivalent\[Sigma]i=",equivalent\[Sigma]i];
Print["S1 \!\(\*SuperscriptBox[\(\[ExponentialE]\), \(SuperscriptBox[equivalent\[Sigma]1, 2] T\)]\)-Si \!\(\*SuperscriptBox[\(\[ExponentialE]\), \(equivalent\[Rho]\\\ equivalent\[Sigma]1\\\ equivalent\[Sigma]i\\\ T\)]\)=",S1 E^(equivalent\[Sigma]1^2 T)-Si E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)];Print[" -(S1 \!\(\*SuperscriptBox[\(\[ExponentialE]\), \(equivalent\[Rho]\\\ equivalent\[Sigma]1\\\ equivalent\[Sigma]i\\\ T\)]\)-Si \!\(\*SuperscriptBox[\(\[ExponentialE]\), \(SuperscriptBox[equivalent\[Sigma]i, 2] T\)]\))=",-(S1 E^(equivalent\[Rho] equivalent\[Sigma]1 equivalent\[Sigma]i T)-Si E^(equivalent\[Sigma]i^2 T))];
Print["gradfunc=",gradfunc[StartingV0,0,0.5Sqrt[InitialV0]]]];
If[printflag==1 || MemberQ[printflag,1] ,
Print["{StartingV0,V0down,V0up}=",{StartingV0,V0down,V0up}];
Print["{0.5\!\(\*SqrtBox[\(InitialV0\)]\),\[Nu]down,\[Nu]up}=",{0.5Sqrt[InitialV0],\[Nu]down,\[Nu]up}];
Print["{0,\[Rho]down,\[Rho]up}=",{0,\[Rho]down,\[Rho]up}];
Print["Entering FindMinimum ....."]];
ss=FindMinimum[func[V0,rho,nu],{{V0,StartingV0,V0down,V0up},{nu,0.5Sqrt[InitialV0],\[Nu]down,\[Nu]up},{rho,0,\[Rho]down,\[Rho]up}},
MaxIterations->200,AccuracyGoal->7,Method->"LevenbergMarquardt",
Gradient->gradfunc[V0,rho,nu]] ;
{ss[[1]],{V0,rho,nu}} /. ss[[2]]
]



(* ::Input::Initialization:: *)
SmileAlphaDigitalesArbitrageFree4[S1_,Si_, \[Rho]1_,\[Nu]1_,V1_,\[Rho]2_,\[Nu]2_,V2_,\[Rho]3_,\[Nu]3_,V3_,\[Rho]4_,\[Nu]4_,V4_,\[Rho]5_,\[Nu]5_,V5_,\[Rho]i_,\[Nu]i_,Vi_,\[Alpha]11_,\[Alpha]12_,\[Alpha]13_,\[Alpha]14_,\[Alpha]i1_,\[Alpha]i2_,\[Alpha]i3_,\[Alpha]i4_,LT_,\[Lambda]_,T_,printflag_,strikelist_]:=
Module[{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],\[Rho]projet\[EAcute],\[Nu]projet\[EAcute],VarVSTotal,CoVarSVSTotal,VarVSIncrementale,CoVarSVSIncrementale,VS,Vb,rhob,nub,nbsteps=120,scale=10,microratio=75,shiftL=0.0001,\[Lambda]smooth=20,
price,digitaleprice,tryfunc1,VbS1,V0x,CompoundK,prices,digitaleprices,S1prices,S1digitaleprices,Siprices,Sidigitaleprices,spreadoptions,tryfunc2,price2,digitaleprice2,prices2,digitaleprices2,rhox,rhobS1,tryfunc3,price3,digitaleprice3,prices3,digitaleprices3,nux,nubS1,ss,VarVS0,CoVarVS0},
If[printflag==1 || MemberQ[printflag,1] ,Print["Inside SmileAlphaDigitalesArbitrageFree4"]];
{equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho]}=ComputeEquivalentBilogFromAlpha[S1,Si, \[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,T];
If[printflag==1 || MemberQ[printflag,1] ,Print["equivalent\[Sigma]1=",equivalent\[Sigma]1," equivalent\[Sigma]i=",equivalent\[Sigma]i," equivalent\[Rho]=",equivalent\[Rho]];];
{VS,VarVSIncrementale,CoVarSVSIncrementale,VarVS0,CoVarVS0}=AlphaDigitaleObservable1iz[S1,Si,\[Alpha]11,\[Alpha]12,\[Alpha]13,\[Alpha]14,\[Alpha]i1,\[Alpha]i2,\[Alpha]i3,\[Alpha]i4,\[Rho]1,\[Nu]1,V1,\[Rho]2,\[Nu]2,V2,\[Rho]3,\[Nu]3,V3,\[Rho]4,\[Nu]4,V4,\[Rho]5,\[Nu]5,V5,\[Rho]i,\[Nu]i,Vi];

If[printflag==1 || MemberQ[printflag,1] ,Print["S1=",S1," Si=",Si];
Print["{VS,VarVSIncrementale,CoVarSVSIncrementale}=",{VS,VarVSIncrementale,CoVarSVSIncrementale}]];
{Vb,rhob,nub}=HestonFromBilogPackaged[S1,Si,equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],T,\[Lambda],LT,\[Lambda]smooth];
If[printflag==1 || MemberQ[printflag,1] ,Print["{Vb,rhob,nub}=",{Vb,rhob,nub}]];
VarVSTotal=nub^2 Vb+VarVSIncrementale;
CoVarSVSTotal=rhob Vb nub+CoVarSVSIncrementale;
\[Rho]projet\[EAcute]=CoVarSVSTotal/Sqrt[Vb VarVSTotal];\[Nu]projet\[EAcute]=Sqrt[VarVSTotal/Vb];

Vb1=2.8343142472871160 * 10^(-006);
\[Rho]projet\[EAcute]1=0.31453253418078975;
\[Nu]projet\[EAcute]1=0.0021364865968095262;
{VbS1,rhobS1,nubS1}=DigitaleNormalHestonFromBilogPackaged[S1,Si,equivalent\[Sigma]1,equivalent\[Sigma]i,equivalent\[Rho],Vb1,\[Rho]projet\[EAcute]1,\[Nu]projet\[EAcute]1,T,\[Lambda],LT,strikelist,\[Lambda]smooth,printflag];
Print["contrainte=",{V0x,Vb,Vb/2,4Vb},{rhox,\[Rho]projet\[EAcute],-0.9,0.9},{nux,\[Nu]projet\[EAcute],\[Nu]projet\[EAcute]/4,4 \[Nu]projet\[EAcute]}];
{{Vb,\[Rho]projet\[EAcute],\[Nu]projet\[EAcute]},{VbS1,rhobS1,nubS1}}
]


(* ::Input::Initialization:: *)
Interpolator3points[x1_,y1_,x2_,y2_,x3_,y3_,x_]:=((x-x3) ((x-x2) (x2-x3) y1+(x-x1) (-x1+x3) y2)+(x-x1) (x-x2) (x1-x2) y3)/((x1-x2) (x1-x3) (x2-x3))


(* ::Input::Initialization:: *)
Interpolator4points[x1_,y1_,x2_,y2_,x3_,y3_,x4_,y4_,x_]:=Module[{xx3=x*x*x,xx2=x*x,x42=x4*x4,x32=x3*x3,x12=x1*x1,x13=x1*x1*x1,x33=x3*x3*x3,x43=x4*x4*x4,x23=x2*x2*x2,x22=x2*x2},(x1 (x1-x3) x3 (x1-x4) (x3-x4) x4 y2+x2 x42 (-x33 y1+x32 x4 y1+x12 (x1-x4) y3)+x12 x2 x32 (-x1+x3) y4+x23 (x4 (-x32 y1+x3 x4 y1+x1 (x1-x4) y3)+x1 x3 (-x1+x3) y4)+x22 (x1 x4 (-x12+x42) y3+x33 (x4 y1-x1 y4)+x3 (-x43 y1+x13 y4))+xx3 (x1 (x1-x4) x4 (y2-y3)+x32 (x4 (y1-y2)+x1 (y2-y4))+x2 (x42 (y1-y3)+x12 (y3-y4)+x32 (-y1+y4))+x3 (x42 (-y1+y2)+x12 (-y2+y4))+x22 (x4 (-y1+y3)+x3 (y1-y4)+x1 (-y3+y4)))+x (x12 (x1-x4) x42 (y2-y3)+x33 (x42 (y1-y2)+x12 (y2-y4))+x22 (x43 (y1-y3)+x13 (y3-y4)+x33 (-y1+y4))+x32 (x43 (-y1+y2)+x13 (-y2+y4))+x23 (x42 (-y1+y3)+x32 (y1-y4)+x12 (-y3+y4)))+xx2 (-x1 x4 (x12-x42) (y2-y3)+x3 (x43 (y1-y2)+x13 (y2-y4))+x23 (x4 (y1-y3)+x1 (y3-y4)+x3 (-y1+y4))+x33 (x4 (-y1+y2)+x1 (-y2+y4))+x2 (x43 (-y1+y3)+x33 (y1-y4)+x13 (-y3+y4))))/((x1-x2) (x1-x3) (x2-x3) (x1-x4) (x2-x4) (x3-x4))]


(* ::Input::Initialization:: *)
Interpolator5points[x1_,y1_,x2_,y2_,x3_,y3_,x4_,y4_,x5_,y5_,x_]:=Module[{},If[(x==x2) , x2,If[(x==x3) , x3,
If[(x>x3) , Interpolator4points[x2,y2,x3,y3,x4,y4,x5,y5,x],
 Interpolator4points[x1,y1,x2,y2,x3,y3,x4,y4,x]]]]]


(* ::Input::Initialization:: *)
Interpolator6points[x1_,y1_,x2_,y2_,x3_,y3_,x4_,y4_,x5_,y5_,x6_,y6_,x_]:=Module[{},If[(x==x2) , x2,If[(x==x3) , x3,
If[(x>x3) , Interpolator5points[x2,y2,x3,y3,x4,y4,x5,y5,x6,y6,x],
 Interpolator5points[x1,y1,x2,y2,x3,y3,x4,y4,x5,y5,x]]]]]


(* ::Input::Initialization:: *)
RiccatiSolveP[\[Kappa]_,b_,c_,\[Lambda]_,\[Theta]_,\[Tau]_]:=Module[{\[Psi]p,\[Psi]m,\[Zeta],A,B},
\[Zeta]=Sqrt[b^2-\[Kappa]^2  c];
\[Psi]p= -b+\[Zeta];
\[Psi]m= b+\[Zeta];
A=-((\[Theta] \[Lambda] ( \[Tau] \[Psi]p +2  Log[(\[Psi]m+\[Psi]p E^(-\[Zeta] \[Tau]))/(2 \[Zeta]  )]))/ (\[Kappa]^2));
B=(c(1-E^(-\[Zeta]  \[Tau])))/(\[Psi]m+\[Psi]p E^(-\[Zeta]  \[Tau]));
{A,B}
]


(* ::Input::Initialization:: *)
NormalPowerCallPayOffFourierTransform[k_,n_,\[Omega]_]:=If[k!=0,-((I (E^(I k^(1/n) \[Omega]) k-(-I \[Omega])^-n Gamma[1+n,-I k^(1/n) \[Omega]]))/\[Omega]),(-I \[Omega])^(-1-n) Gamma[1+n]]


(* ::Input::Initialization:: *)
HestonPowerNormalCallN[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=n+0.5,\[Omega]},
NIntegrate[E^(-I (\[Omega] +\[Lambda] I)S0) NormalHestonFondamentalTransform[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Omega]+I \[Lambda],T]NormalPowerCallPayOffFourierTransform[k,n,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
HestonPowerNormalPutN[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=-0.5,\[Omega]},
NIntegrate[E^(-I (\[Omega] +\[Lambda] I)S0) NormalHestonFondamentalTransform[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Omega]+I \[Lambda],T]NormalPowerCallPayOffFourierTransform[k,n,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
HestonPowerNormalCallAux[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=n+0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],E^(-I (\[Omega] +\[Lambda] I)S0) NormalHestonFondamentalTransform[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Omega] +\[Lambda] I,T]NormalPowerCallPayOffFourierTransform[k,n,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[20],
10/T,5/T,10^(-10),1000,1/T,LegendreCoeffs[60]][[2]]]]


(* ::Input::Initialization:: *)
HestonPowerNormalPutAux[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=-0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],E^(-I (\[Omega] +\[Lambda] I)S0) NormalHestonFondamentalTransform[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Omega] +\[Lambda] I,T]NormalPowerCallPayOffFourierTransform[k,n,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[20],
10/T,5/T,10^(-10),1000,1/T,LegendreCoeffs[60]][[2]]]]


(* ::Input::Initialization:: *)
HestonPowerNormalCall[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=Module[{\[Theta]v1,\[Kappa]1,V1,S01,k1,L,prix},
L=Sqrt[1./V];\[Theta]v1=L^2 \[Theta]v;\[Kappa]1=L \[Kappa];V1=1.0;S01=L S0;k1=L^n k;
prix=HestonPowerNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1,V1,S01,k1,n,T];
L^-n*prix]


(* ::Input::Initialization:: *)
HestonPowerNormalPut[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=Module[{\[Theta]v1,\[Kappa]1,V1,S01,k1,L,prix},
L=Sqrt[1./V];\[Theta]v1=L^2 \[Theta]v;\[Kappa]1=L \[Kappa];V1=1.0;S01=L S0;k1=L^n k;
prix=HestonPowerNormalPutAux[\[Rho],\[Lambda]v,\[Theta]v1,\[Kappa]1,V1,S01,k1,n,T];
L^-n*prix]


(* ::Input::Initialization:: *)
HestonNormalVariance[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,T_]:=Module[{call,put},
call=HestonPowerNormalCall[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,S0^2,2,T];
put=HestonPowerNormalPut[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,S0^2,2,T];
call-put]


(* ::Input::Initialization:: *)
HestonNormalVarianceTrace[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,T_]:=Module[{call,put},
call=HestonPowerNormalCall[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,S0^2,2,T];
put=HestonPowerNormalPut[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,S0^2,2,T];
Print["T=",T," call=",call," put=",put];
call-put]


(* ::Input::Initialization:: *)
NormalHestonFondamentalTransformLog[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,\[Omega]_,\[Tau]_]:=Module[{\[Zeta],\[Psi]p ,\[Psi]m,A,B,arg\[Zeta]},
\[Zeta]=Sqrt[(\[Lambda]v+\[Rho] \[Kappa] I \[Omega])^2+\[Kappa]^2 ( \[Omega]^2)];
\[Psi]p =-(\[Lambda]v+\[Rho] \[Kappa]  I \[Omega])+\[Zeta];
\[Psi]m =(\[Lambda]v+\[Rho] \[Kappa]  I \[Omega])+\[Zeta];
A=-(( \[Theta]v \[Lambda]v (\[Tau] \[Psi]p+2 Log[(\[Psi]m+E^(-\[Zeta] \[Tau]) \[Psi]p)/(2\[Zeta])]))/ (\[Kappa]^2)   );
B=( -( \[Omega]^2)(1-E^(-\[Zeta]  \[Tau])))/(\[Psi]m+\[Psi]p E^(-\[Zeta]  \[Tau]));
A+B V]


(* ::Input::Initialization:: *)
D2=D[NormalHestonFondamentalTransformLog[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Omega],\[Tau]],{\[Omega],2}];
D2LogNormalHestonFondamentalTransform=Function[{\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Tau]},Evaluate[1/I^2 D2/. \[Omega]->0]];


(* ::Input::Initialization:: *)
D2LogNormalHestonFondamentalTransform=Function[{\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Tau]},Evaluate[Simplify[D2LogNormalHestonFondamentalTransform[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,\[Tau]],\[Lambda]v>0]]];


(* ::Input::Initialization:: *)
PowerLogHestonNormalCallN[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=n+0.5,\[Omega]},
NIntegrate[LogNormalHestonCallIntegrand[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,1,n,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
PowerLogHestonNormalCallN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=n+0.5,\[Omega]},
NIntegrate[LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,k,1,n,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
PowerLogHestonNormalCallN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=n+0.5,\[Omega]},
NIntegrate[LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,k,1,n,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
PowerLogHestonNormalPutN[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=-0.5,\[Omega]},
NIntegrate[LogNormalHestonCallIntegrand[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,1,n,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
PowerLogHestonNormalPutN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=-0.5,\[Omega]},
NIntegrate[LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,k,1,n,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
PowerLogHestonNormalPutN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=-0.5,\[Omega]},
NIntegrate[LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,k,1,n,T,\[Omega] +\[Lambda] I],
{\[Omega],0,Infinity},MaxRecursion->30]]]


(* ::Input::Initialization:: *)
LogHestonNormalVarianceN[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,T_]:=Module[{call,put},
call=PowerLogHestonNormalCallN[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,S0^2,2,T];
put=PowerLogHestonNormalPutN[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,S0^2,2,T];
call-put
]  


(* ::Input::Initialization:: *)
LogHestonNormalVarianceN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,T_]:=Module[{call,put},
call=PowerLogHestonNormalCallN[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,S0^2,2,T];
put=PowerLogHestonNormalPutN[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,S0^2,2,T];
call-put
]  


(* ::Input::Initialization:: *)
LogHestonNormalVarianceN[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,T_]:=Module[{call,put},
call=PowerLogHestonNormalCallN[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,S0^2,2,T];
put=PowerLogHestonNormalPutN[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,S0^2,2,T];
call-put
]  


(* ::Input::Initialization:: *)
PowerLogHestonNormalCallAux[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=n+0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,1,n,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
PowerLogHestonNormalCallAux[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=n+0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,k,1,n,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
PowerLogHestonNormalCallAux[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=n+0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,k,1,n,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
PowerLogHestonNormalPutAux[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=-0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,k,1,n,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
PowerLogHestonNormalPutAux[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=-0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,k,1,n,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
PowerLogHestonNormalPutAux[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,n_,T_]:=S0^n-1/\[Pi] Re[Module[{\[Lambda]=-0.5,\[Omega]},
AdaptativeIntegrate[Function[\[Omega],LogNormalHestonCallIntegrand[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,k,1,n,T,\[Omega] +\[Lambda] I]],LegendreCoeffs[60],LegendreCoeffs[3],
10,1,10^(-10),1000,1,LegendreCoeffs[20]][[2]]]]


(* ::Input::Initialization:: *)
PowerLogHestonNormalCall[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=Module[{},
S0^n PowerLogHestonNormalCallAux[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,1,k/S0^n,n,T]
]


(* ::Input::Initialization:: *)
PowerLogHestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,n_,T_]:=Module[{},
S0^n PowerLogHestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,1,k/S0^n,n,T]
]


(* ::Input::Initialization:: *)
PowerLogHestonNormalCall[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,n_,T_]:=Module[{},
S0^n PowerLogHestonNormalCallAux[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,1,k/S0^n,n,T]
]


(* ::Input::Initialization:: *)
PowerLogHestonNormalPut[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,k_,n_,T_]:=Module[{},
S0^n PowerLogHestonNormalPutAux[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,1,k/S0^n,n,T]
]


(* ::Input::Initialization:: *)
PowerLogHestonNormalPut[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,k_,n_,T_]:=Module[{},
S0^n PowerLogHestonNormalPutAux[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,1,k/S0^n,n,T]
]


(* ::Input::Initialization:: *)
PowerLogHestonNormalPut[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,k_,n_,T_]:=Module[{},
S0^n PowerLogHestonNormalPutAux[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,1,k/S0^n,n,T]
]


(* ::Input::Initialization:: *)
LogHestonNormalVariance[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,T_]:=Module[{call,put},
call=PowerLogHestonNormalCall[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,S0^2,2,T];
put=PowerLogHestonNormalPut[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,S0^2,2,T];
call-put
]  


(* ::Input::Initialization:: *)
LogHestonNormalVariance[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,T_]:=Module[{call,put},
call=PowerLogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,S0^2,2,T];
put=PowerLogHestonNormalPut[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,S0^2,2,T];
call-put
]  


(* ::Input::Initialization:: *)
LogHestonNormalVariance[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,T_]:=Module[{call,put},
call=PowerLogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,S0^2,2,T];
put=PowerLogHestonNormalPut[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,S0^2,2,T];
call-put
]  


(* ::Input::Initialization:: *)
LogHestonNormalVarianceTrace[\[Rho]_,\[Lambda]v_,\[Theta]v_,\[Kappa]_,V_,S0_,T_]:=Module[{call,put},
call=PowerLogHestonNormalCall[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,S0^2,2,T];
put=PowerLogHestonNormalPut[\[Rho],\[Lambda]v,\[Theta]v,\[Kappa],V,S0,S0^2,2,T];
Print["call=",call," put=",put];
call-put
]  


(* ::Input::Initialization:: *)
LogHestonNormalVarianceTrace[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,S0_,T_]:=Module[{call,put},
call=PowerLogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,S0^2,2,T];
put=PowerLogHestonNormalPut[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,S0,S0^2,2,T];
Print["call=",call," put=",put];
call-put
]  


(* ::Input::Initialization:: *)
LogHestonNormalVarianceTrace[\[Rho]1_,\[Lambda]v1_,\[Theta]v1_,\[Kappa]1_,V1_,\[Rho]2_,\[Lambda]v2_,\[Theta]v2_,\[Kappa]2_,V2_,\[Rho]3_,\[Lambda]v3_,\[Theta]v3_,\[Kappa]3_,V3_,S0_,T_]:=Module[{call,put},
call=PowerLogHestonNormalCall[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,S0^2,2,T];
put=PowerLogHestonNormalPut[\[Rho]1,\[Lambda]v1,\[Theta]v1,\[Kappa]1,V1,\[Rho]2,\[Lambda]v2,\[Theta]v2,\[Kappa]2,V2,\[Rho]3,\[Lambda]v3,\[Theta]v3,\[Kappa]3,V3,S0,S0^2,2,T];
Print["call=",call," put=",put];
call-put
]  



